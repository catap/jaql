
;//------------------- TEST-CASE -----------------
//---------------------------------------------------------------------------
// Tests:
//   composite input/output adapaters
//   parallelization of union (coming soon)
//   parallelization of tee
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Composite input/output adapaters
//---------------------------------------------------------------------------

r = hdfs('R');
;//------------------- TEST-CASE -----------------

s = hdfs('S');
;//------------------- TEST-CASE -----------------

t = hdfs('T');
;//------------------- TEST-CASE -----------------


R = read(r);
;//------------------- TEST-CASE -----------------

S = read(s);
;//------------------- TEST-CASE -----------------

T = read(t);
;//------------------- TEST-CASE -----------------


// Defines a composite descriptor:
//   Read produces the union of descriptors.
//   Write partitions the values written.  It expects the values to be [i,x] pairs where
//      i is an index to a output descriptor and
//      x is value that will be written to only to descriptor[i]
//      if a key is written, it is passed to descriptor[i] as well.
compositeDescriptor = fn( descriptors )
   { inoptions:  { adapter: 'com.ibm.jaql.io.hadoop.CompositeInputAdapter' },
     outoptions: { adapter: 'com.ibm.jaql.io.hadoop.CompositeOutputAdapter' },
     descriptors
   };
;//------------------- TEST-CASE -----------------


// write even values to R and odd values to S
range(10) 
 -> transform [ mod($,2), $ ]
 -> write( compositeDescriptor( [r, s] ) )
;

;//--------------------- RESULT ------------------

{
  "descriptors": [
    {
      "location": "R",
      "type": "hdfs"
    },
    {
      "location": "S",
      "type": "hdfs"
    }
  ],
  "inoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeInputAdapter"
  },
  "outoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeOutputAdapter"
  }
}

;//------------------- TEST-CASE -----------------


// Just evens
R;

;//--------------------- RESULT ------------------

[
  0,
  2,
  4,
  6,
  8
]

;//------------------- TEST-CASE -----------------


// Just odds
S;

;//--------------------- RESULT ------------------

[
  1,
  3,
  5,
  7,
  9
]

;//------------------- TEST-CASE -----------------


// Read the union of R and S in one read.
read( compositeDescriptor([r,s]) );

;//--------------------- RESULT ------------------

[
  0,
  2,
  4,
  6,
  8,
  1,
  3,
  5,
  7,
  9
]

;//------------------- TEST-CASE -----------------


// Try a map/reduce job
read( compositeDescriptor([r,s]) )
 -> transform $ + 10
 -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// everything with 10 added
T;

;//--------------------- RESULT ------------------

[
  10,
  12,
  14,
  16,
  18,
  11,
  13,
  15,
  17,
  19
]

;//------------------- TEST-CASE -----------------


// Write via map/reduce
T -> transform [ ($ - 10) / 5, $ ]
  -> write( compositeDescriptor([r,s]) )
;

;//--------------------- RESULT ------------------

{
  "descriptors": [
    {
      "location": "R",
      "type": "hdfs"
    },
    {
      "location": "S",
      "type": "hdfs"
    }
  ],
  "inoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeInputAdapter"
  },
  "outoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeOutputAdapter"
  }
}

;//------------------- TEST-CASE -----------------


// 10..14 in R
R;

;//--------------------- RESULT ------------------

[
  10,
  12,
  14,
  11,
  13
]

;//------------------- TEST-CASE -----------------


// 15..19 in S
S;

;//--------------------- RESULT ------------------

[
  16,
  18,
  15,
  17,
  19
]

;//------------------- TEST-CASE -----------------


// Write via from reducer of map/reduce
T -> group by x=mod($,2) into [ x, sum($) ]
  -> write( compositeDescriptor([r,s]) )
;

;//--------------------- RESULT ------------------

{
  "descriptors": [
    {
      "location": "R",
      "type": "hdfs"
    },
    {
      "location": "S",
      "type": "hdfs"
    }
  ],
  "inoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeInputAdapter"
  },
  "outoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeOutputAdapter"
  }
}

;//------------------- TEST-CASE -----------------


// [sum([10,12,14,16,18]) = 70] in R
R;

;//--------------------- RESULT ------------------

[
  70
]

;//------------------- TEST-CASE -----------------


// [sum([11,13,15,17,19]) = 75] in S
S;

;//--------------------- RESULT ------------------

[
  75
]

;//------------------- TEST-CASE -----------------


//---------------------------------------------------------------------------
// TODO: Union
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Tee 
//---------------------------------------------------------------------------

range(10) -> write(r);

;//--------------------- RESULT ------------------

{
  "location": "R",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

range(0) -> write(s);

;//--------------------- RESULT ------------------

{
  "location": "S",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

range(0) -> write(t);

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


R;

;//--------------------- RESULT ------------------

[
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9
]

;//------------------- TEST-CASE -----------------

S;

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------

T;

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------



// Very simple tee that writes two copies of a file
R -> tee( -> write(s) )
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

S;

;//--------------------- RESULT ------------------

[
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9
]

;//------------------- TEST-CASE -----------------

T;

;//--------------------- RESULT ------------------

[
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9
]

;//------------------- TEST-CASE -----------------


// Forms a single map job writing to two files
//   note: tee(a, -> e) == tee(a, f(i) i -> e)
R -> transform $ + 200
  -> tee( 
       -> transform $ + 10 
       -> write(s) 
     )
  -> transform $ + 20
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 210..219
S;

;//--------------------- RESULT ------------------

[
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219
]

;//------------------- TEST-CASE -----------------


// 220..229
T;

;//--------------------- RESULT ------------------

[
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229
]

;//------------------- TEST-CASE -----------------



// Without a leading transform
R -> tee( 
      -> transform $+10 
      -> write(s) 
     )
  -> transform $+20
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 10..19
S;

;//--------------------- RESULT ------------------

[
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19
]

;//------------------- TEST-CASE -----------------


// 20..29
T;

;//--------------------- RESULT ------------------

[
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29
]

;//------------------- TEST-CASE -----------------



// With a stream returned instead of writing
R -> transform $+100
  -> tee( -> transform $+10 -> write(s) )
  -> transform $+20
;

;//--------------------- RESULT ------------------

[
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129
]

;//------------------- TEST-CASE -----------------


// 110..119
S;

;//--------------------- RESULT ------------------

[
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119
]

;//------------------- TEST-CASE -----------------



// This should eliminates the tee as dead code, but it doesn't yet...
R -> transform $+200
  -> tee( -> transform $+10 )
  -> transform $+20
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 220..229
T;

;//--------------------- RESULT ------------------

[
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229
]

;//------------------- TEST-CASE -----------------


// Make sure filter and expand work too.
R -> transform $+100
  -> tee( -> filter $ < 107 -> expand [$+200, $+300] -> write(s) )
  -> filter $ > 103 
  -> transform $+400 
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 300..306 + 400..406
S;

;//--------------------- RESULT ------------------

[
  300,
  400,
  301,
  401,
  302,
  402,
  303,
  403,
  304,
  404,
  305,
  405,
  306,
  406
]

;//------------------- TEST-CASE -----------------


// 504..509
T;

;//--------------------- RESULT ------------------

[
  504,
  505,
  506,
  507,
  508,
  509
]

;//------------------- TEST-CASE -----------------



c = hdfs('C');
;//------------------- TEST-CASE -----------------

d = hdfs('D');
;//------------------- TEST-CASE -----------------

f = hdfs('F');
;//------------------- TEST-CASE -----------------

g = hdfs('G');
;//------------------- TEST-CASE -----------------


// This should produce one map-only job
R -> transform { a: $ }
  -> tee( -> transform { b: $.a }
          -> tee( -> transform { c: $.b } 
                  -> write(c) )
          -> transform { d: $.b } 
          -> write(d) )
  -> transform { e: $.a }
  -> tee( -> transform { f: $.e } 
          -> write(f) )
  -> transform { g: $.e } 
  -> write(g)
;

;//--------------------- RESULT ------------------

{
  "location": "G",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// c recs
read(c);

;//--------------------- RESULT ------------------

[
  {
    "c": 0
  },
  {
    "c": 1
  },
  {
    "c": 2
  },
  {
    "c": 3
  },
  {
    "c": 4
  },
  {
    "c": 5
  },
  {
    "c": 6
  },
  {
    "c": 7
  },
  {
    "c": 8
  },
  {
    "c": 9
  }
]

;//------------------- TEST-CASE -----------------


// d recs
read(d);

;//--------------------- RESULT ------------------

[
  {
    "d": 0
  },
  {
    "d": 1
  },
  {
    "d": 2
  },
  {
    "d": 3
  },
  {
    "d": 4
  },
  {
    "d": 5
  },
  {
    "d": 6
  },
  {
    "d": 7
  },
  {
    "d": 8
  },
  {
    "d": 9
  }
]

;//------------------- TEST-CASE -----------------


// f recs
read(f);

;//--------------------- RESULT ------------------

[
  {
    "f": 0
  },
  {
    "f": 1
  },
  {
    "f": 2
  },
  {
    "f": 3
  },
  {
    "f": 4
  },
  {
    "f": 5
  },
  {
    "f": 6
  },
  {
    "f": 7
  },
  {
    "f": 8
  },
  {
    "f": 9
  }
]

;//------------------- TEST-CASE -----------------


// g recs
read(g);

;//--------------------- RESULT ------------------

[
  {
    "g": 0
  },
  {
    "g": 1
  },
  {
    "g": 2
  },
  {
    "g": 3
  },
  {
    "g": 4
  },
  {
    "g": 5
  },
  {
    "g": 6
  },
  {
    "g": 7
  },
  {
    "g": 8
  },
  {
    "g": 9
  }
]

;//------------------- TEST-CASE -----------------



// Share a reducer after aggregation
R -> transform { x: mod($,3), y: $ }                 // 0,0; 1,1; 2,2; 0,3; 1,4; 2,5; 0,6; 1,7; 2,8; 0,9;
  -> group by x = $.x into { x, s: sum($[*].y) }     // 0,18; 1,12; 2,15;
  -> tee( -> filter $.x <= 1                         // 0,18; 1,12;
          -> write(s) )
  -> filter $.x >= 1                                 // 1,12; 2,15;
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 0,18; 1,12;
S -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "s": 18,
    "x": 0
  },
  {
    "s": 12,
    "x": 1
  }
]

;//------------------- TEST-CASE -----------------


// 1,12; 2,15;
T -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "s": 12,
    "x": 1
  },
  {
    "s": 15,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------


// Share a reducer with aggregation in the tee
// TODO: This could use combiners but it doesn't yet...
R -> transform { x: mod($,3), y: $ }                 // 0,0; 1,1; 2,2; 0,3; 1,4; 2,5; 0,6; 1,7; 2,8; 0,9;
  -> group by x = $.x into { x, ys: $[*].y }         // 0,[0,3,6,9]; 1,[1,4,7]; 2,[2,5,8];
  -> tee( -> transform { $.x, s: sum($.ys) }         // 0,18; 1,12; 2,15;
          -> write(s) )
  -> transform { $.x, t: count($.ys) }               // 0,4; 1,3; 2,3;
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 0,18; 1,12; 2,15;
S -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "s": 18,
    "x": 0
  },
  {
    "s": 12,
    "x": 1
  },
  {
    "s": 15,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------


// 0,4; 1,3; 2,3;
T -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "t": 4,
    "x": 0
  },
  {
    "t": 3,
    "x": 1
  },
  {
    "t": 3,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------


// Tee where one is not shareable
R -> transform { x: mod($,3), y: $ }
  -> tee( -> group by x=$.x 
                into { x, n: min($[*].y) }
          -> write(s) )
  -> filter $.x < 2
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


S -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "n": 0,
    "x": 0
  },
  {
    "n": 1,
    "x": 1
  },
  {
    "n": 2,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------

T;

;//--------------------- RESULT ------------------

[
  {
    "x": 0,
    "y": 0
  },
  {
    "x": 1,
    "y": 1
  },
  {
    "x": 0,
    "y": 3
  },
  {
    "x": 1,
    "y": 4
  },
  {
    "x": 0,
    "y": 6
  },
  {
    "x": 1,
    "y": 7
  },
  {
    "x": 0,
    "y": 9
  }
]

;//------------------- TEST-CASE -----------------


// Tee where the other is not sharable
R -> transform { x: mod($,3), y: $ }
  -> tee( -> filter $.x > 1
          -> write(s) )
  -> group by a=$.x 
      into { a, m: max($[*].y) }
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

S;

;//--------------------- RESULT ------------------

[
  {
    "x": 2,
    "y": 2
  },
  {
    "x": 2,
    "y": 5
  },
  {
    "x": 2,
    "y": 8
  }
]

;//------------------- TEST-CASE -----------------

T -> sort by [$.a];

;//--------------------- RESULT ------------------

[
  {
    "a": 0,
    "m": 9
  },
  {
    "a": 1,
    "m": 7
  },
  {
    "a": 2,
    "m": 8
  }
]

;//------------------- TEST-CASE -----------------


// Tee that is not sharable at all
// TODO: this example currently does a dumb thing: 
// It writes two temps with the exactly the same stuff.
R -> transform { x: mod($,3), y: $ }
  -> tee( -> group by x=$.x 
                into { x, n: min($[*].y) }
          -> write(s) )
  -> group by a=$.x 
      into { a, m: max($[*].y) }
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

S -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "n": 0,
    "x": 0
  },
  {
    "n": 1,
    "x": 1
  },
  {
    "n": 2,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------

T -> sort by [$.a];

;//--------------------- RESULT ------------------

[
  {
    "a": 0,
    "m": 9
  },
  {
    "a": 1,
    "m": 7
  },
  {
    "a": 2,
    "m": 8
  }
]

;//------------------- TEST-CASE -----------------


;//------------------- TEST-DONE -----------------
