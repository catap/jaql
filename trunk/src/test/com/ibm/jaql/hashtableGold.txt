//===========================================================================
// Create data
//===========================================================================

N = 10000;##
"N"

fd = hdfs('test');##
"fd"


range(1,N) 
 -> transform { i: $, key1: $, key2: $, key3: $, more: -$ }
 -> write(fd);##
{
  "location": "test",
  "type": "hdfs"
}


//===========================================================================
// keyLookup tests
//===========================================================================

[ [1,1], [1,2], [2,3], [3,4] ] -> keyLookup( [ [1,5], [1,6], [3,7] ] );##
[
  [
    1,
    1,
    6
  ],
  [
    1,
    2,
    6
  ],
  [
    2,
    3,
    null
  ],
  [
    3,
    4,
    7
  ]
]


// Only outer keys that match to a non-null inner key are returned
memoryJoin = fn(outer, outerKeyFn, inner, innerKeyFn, projectFn) (
  outer
    -> transform [outerKeyFn($), $]
    -> keyLookup( inner -> transform [innerKeyFn($), $] )
    -> filter exists($[2]) // make into inner join
    -> transform projectFn($[1], $[2])
);##
"memoryJoin"


// All outer rows will survive the join
memoryJoinPreserve = fn(outer, outerKeyFn, inner, innerKeyFn, projectFn) (
  outer
    -> transform [outerKeyFn($), $]
    -> keyLookup( inner -> transform [innerKeyFn($), $] )
    -> transform projectFn($[1], $[2])
);##
"memoryJoinPreserve"


inner = range(1,3) -> transform { x: $*2, y: $ };##
"inner"

outer = range(0,7) -> transform { a: $, b: $ };##
"outer"


memoryJoin( outer, fn(o) o.b,
            inner, fn(i) i.x,
            fn(o,i) { o, i } )
;##
[
  {
    "i": {
      "x": 2,
      "y": 1
    },
    "o": {
      "a": 2,
      "b": 2
    }
  },
  {
    "i": {
      "x": 4,
      "y": 2
    },
    "o": {
      "a": 4,
      "b": 4
    }
  },
  {
    "i": {
      "x": 6,
      "y": 3
    },
    "o": {
      "a": 6,
      "b": 6
    }
  }
]


memoryJoinPreserve(
    outer, fn(o) o.b,
    inner, fn(i) i.x,
    fn(o,i) { o, i } )
;##
[
  {
    "i": null,
    "o": {
      "a": 0,
      "b": 0
    }
  },
  {
    "i": null,
    "o": {
      "a": 1,
      "b": 1
    }
  },
  {
    "i": {
      "x": 2,
      "y": 1
    },
    "o": {
      "a": 2,
      "b": 2
    }
  },
  {
    "i": null,
    "o": {
      "a": 3,
      "b": 3
    }
  },
  {
    "i": {
      "x": 4,
      "y": 2
    },
    "o": {
      "a": 4,
      "b": 4
    }
  },
  {
    "i": null,
    "o": {
      "a": 5,
      "b": 5
    }
  },
  {
    "i": {
      "x": 6,
      "y": 3
    },
    "o": {
      "a": 6,
      "b": 6
    }
  },
  {
    "i": null,
    "o": {
      "a": 7,
      "b": 7
    }
  }
]


memoryJoin( read(fd) -> filter mod($.key3,3) == 0, fn(o) o.key1,
            read(fd) -> filter mod($.key3,5) == 0, fn(i) i.key2,
            fn(o,i) { o, i } )
 -> count()
;##
666


memoryJoinPreserve( 
     read(fd) -> filter mod($.key3,3) == 0, fn(o) o.key1,
     read(fd) -> filter mod($.key3,5) == 0, fn(i) i.key2,
     fn(o,i) { o, i } )
 -> count()
;##
3333



//===========================================================================
// sharedHashtableN tests
//===========================================================================

//---------------------------------------------------------------------------
// htJoin hides the detail of the batches but it is a little slower because
// it materializes a batch for each use.  It also has less room for (thread)
// parallelism (pairwise could run each leg in parallel).  On the other hand,
// it filters non-matching items
// TODO: Move these into a module!
//---------------------------------------------------------------------------
htJoinPair = fn(input, keyFn, probeFn, batchSize=100)
  input 
   -> batch(batchSize) 
   -> expand pairwise( $, $ -> transform keyFn($) -> probeFn() -> transform $[1] )
;##
"htJoinPair"


htJoin = fn(input, keyFn, probeFn, projectFn, batchSize=100)
  input 
   -> htJoinPair(keyFn, probeFn, batchSize)
   -> filter not isnull($[1])
   -> transform projectFn($[0], $[1])
;##
"htJoin"


htJoinPreserve = fn(input, keyFn, probeFn, projectFn, batchSize=100)
  input 
   -> htJoinPair(keyFn, probeFn, batchSize)
   -> transform projectFn($[0], $[1])
;##
"htJoinPreserve"



buildN = fn(url, buildfn, scheme) 
  fn(keys) 
    sharedHashtableN( keys, url, buildfn, scheme,
                      serverThread=true, // server thread used to keep ant from waiting on us (we could also reduce timeout or create a shutdown command)
                      serverTimeout=2*60*1000) // 2 minutes
;##
"buildN"


// Build a hash table that maps for every k * [1..N] to a record
probeI = fn(k) 
  buildN(strcat('http://localhost:9055/table',k),
         fn() read(fd) -> transform [$.i*k, { k, x: -$.i }],
         schema [ long, { k:long, x:long } ]);##
"probeI"


probe2 = probeI(2);##
"probe2"

probe3 = probeI(3);##
"probe3"

probe5 = probeI(5);##
"probe5"


// Count the multiples of 2
read(fd)
 -> htJoin( fn(i) i.key1, probe2, fn(i,value2) { i.*, value2 } )
 -> group into count($)
;##
[
  5000
]


// Count the multiples of 3
read(fd)
 -> htJoin( fn(i) i.key2, probe3, fn(i,value3) { i.*, value3 } )
 -> group into count($)
;##
[
  3333
]


// Count the multiples of 5
read(fd)
 -> htJoin( fn(i) i.key3, probe5, fn(i,value5) { i.*, value5 } )
 -> group into count($)
;##
[
  2000
]


// Count the multiples of 5 with twice the effort
read(fd)
 -> htJoin( fn(i) i.key3, probe5, fn(i,value5) { i.*, value5 } )
 -> htJoin( fn(i) i.key3, probe5, fn(i,value5b) { i.*, value5b } )
 -> group into count($)
;##
[
  2000
]


// Count the multiples of 2, 3
read(fd)
 -> htJoin( fn(i) i.key1, probe2, fn(i,value2) { i.*, value2 } )
 -> htJoin( fn(i) i.key2, probe3, fn(i,value3) { i.*, value3 } )
 -> group into count($)
;##
[
  1666
]


// Count the multiples of 2, 3, and 5 
read(fd)
 -> htJoin( fn(i) i.key1, probe2, fn(i,value2) { i.*, value2 } )
 -> htJoin( fn(i) i.key2, probe3, fn(i,value3) { i.*, value3 } )
 -> htJoin( fn(i) i.key3, probe5, fn(i,value5) { i.*, value5 } )
 -> group into count($)
;##
[
  333
]


// Count the multiples of 5, 3, and 2
read(fd)
 -> htJoin( fn(i) i.key3, probe5, fn(i,value5) { i.*, value5 } )
 -> htJoin( fn(i) i.key2, probe3, fn(i,value3) { i.*, value3 } )
 -> htJoin( fn(i) i.key1, probe2, fn(i,value2) { i.*, value2 } )
 -> group into count($)
;##
[
  333
]


// Count the multiples of 2 OR 3
read(fd)
 -> htJoinPreserve( fn(i) i.key1, probe2, fn(i,value2) { i.*, value2 } )
 -> htJoinPreserve( fn(i) i.key2, probe3, fn(i,value3) { i.*, value3 } )
 -> filter not isnull($.value2) or not isnull($.value3)
 -> group into count($)
;##
[
  6667
]


// Count the multiples of 2, 3, and 5 
read(fd)
 -> batch(100) 
 -> expand pairwise( $,
                     $ -> transform $.key1 -> probe2() -> transform { value2: $[1] },
                     $ -> transform $.key2 -> probe3() -> transform { value3: $[1] },
                     $ -> transform $.key3 -> probe5() -> transform { value5: $[1] } )
 -> transform record($)
 -> filter not isnull($.value2) 
       and not isnull($.value3)
       and not isnull($.value5)
 -> count()
;##
333

