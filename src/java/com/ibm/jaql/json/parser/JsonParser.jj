/*
 * Copyright (C) IBM Corp. 2008.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
/**
 * JavaCC file
 */

options {
    JDK_VERSION = "1.5";
    STATIC=false;
    UNICODE_INPUT=true;
}

PARSER_BEGIN(JsonParser)
package com.ibm.jaql.json.parser;

import java.io.PrintStream;
import java.io.StringReader;
import java.util.ArrayList;

import com.ibm.jaql.json.constructor.JsonConstructor;
import com.ibm.jaql.json.type.JsonValue;
import com.ibm.jaql.json.type.JsonString;
import com.ibm.jaql.json.type.JsonLong;
import com.ibm.jaql.json.type.JsonDecimal;
import com.ibm.jaql.json.type.JsonDouble;
import com.ibm.jaql.json.type.JsonBool;
import com.ibm.jaql.json.type.BufferedJsonArray;
import com.ibm.jaql.json.type.BufferedJsonRecord;
import com.ibm.jaql.json.type.JsonEncoding;
import com.ibm.jaql.json.util.JsonIterator;

import com.ibm.jaql.util.BaseUtil;

/** 
 *  This class is generated by JavaCC. Don't modify it directly.
 */
public class JsonParser 
{
  public static final JsonValue NIL = new JsonValue() {
    @Override
    public int compareTo(Object obj)
    {
      throw new UnsupportedOperationException();
    }

    @Override
    public JsonEncoding getEncoding()
    {
      throw new UnsupportedOperationException();
    }

    @Override
    public long longHashCode()
    {
      throw new UnsupportedOperationException();
    }

    @Override
    public JsonValue getCopy(JsonValue target) throws Exception
    {
      throw new UnsupportedOperationException();
    }

        @Override
    public JsonValue getImmutableCopy() throws Exception
    {
      throw new UnsupportedOperationException();
    }
  };
    
  public JsonParser() 
  {
    this(new StringReader(""));
  }
  
  public JsonValue parse(String jsonString) throws ParseException 
  {
    ReInit(new StringReader(jsonString));
    try 
    {
      return TopVal();
    }
    catch (ParseException e) 
    {
      // rethrow to include the original jsonString:
      throw new ParseException("Cannot parse '" +jsonString+ "': " + e.getMessage());
    }
  }
  
  public JsonIterator parseArray(String jsonString) 
  {
    ReInit(new StringReader(jsonString));
    return arrayIterator();
  }

  public JsonIterator arrayIterator()
  {
    return new JsonIterator()
    {
      boolean atStart = true;
      
      public boolean moveNext() throws ParseException
      {
        currentValue = atStart ? ArrayFirst() : ArrayNext();
        atStart = false;
        if( currentValue == NIL )
        {
          return false;
        }
        return true;
      }
    };
  }
}
PARSER_END(JsonParser)

SKIP:
{
    " "
|   "\r"
|   "\t"
|   "\n"
}

TOKEN:
{
    <COLON:       ":" >
|   <COMMA:       "," >
|   <#DIGIT:      ["0"-"9"] >
|   <#LETTER:     ["a"-"z","A"-"Z"] >
|   <MAP_BEGIN:   "{" >
|   <MAP_END:     "}" >
|   <ARRAY_BEGIN: "[" >
|   <ARRAY_END:   "]" >
|   <LPAREN:      "(" >
|   <RPAREN:      ")" >
|   <PLUS:        "+" >
|   <LONG:        ("-"|"+")? (<DIGIT>)+ >
|   <REAL:        ("-"|"+")? (<DIGIT>)+ ("." (<DIGIT>)+)? (("e"|"E") ("-"|"+")? (<DIGIT>)+)? >
|   <DECIMAL:     <REAL> "m" >
|   <DOUBLE:      <REAL> "d" >
|   <TRUE:        ["t","T"]["r","R"]["u","U"]["e","E"] >
|   <FALSE:       ["f","F"]["a","A"]["l","L"]["s","S"]["e","E"] >
|   <NULL:        ["n","N"]["u","U"]["l","L"]["l","L"] >
|   <ID:    ("@"|"_"|<LETTER>) ("@"|"_"|"#"|<LETTER>|<DIGIT>)* >
}

MORE:
{
    < "'"  > { image.setLength(0); } : IN_STRING1
|   < "\"" > { image.setLength(0); } : IN_STRING2
}

<IN_STRING1> TOKEN: { <STRING1: "'"  > { image.setLength(image.length()-1); matchedToken.image = image.toString(); } : DEFAULT }
<IN_STRING2> TOKEN: { <STRING2: "\"" > { image.setLength(image.length()-1); matchedToken.image = image.toString(); } : DEFAULT }

<IN_STRING1, IN_STRING2> MORE:
{
  <"\\\r\n">           { image.setLength(image.length()-3); }
| <("\\" ("\n"|"\r"))> { image.setLength(image.length()-2); }
| <"\r\n"> {
      int l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\n');
  }
| <"\n">
| <"\r"> { image.setCharAt(image.length()-1, '\n'); }
| <"\\\'"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\'');
  }
| <"\\\"" > {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\"');
  }
| <"\\\\"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\\');
  }
| <"\\/"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '/');
  }
| <"\\b"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\b');
  }
| <"\\f"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\f');
  }
| <"\\n"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\n');
  }
| <"\\r"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\r');
  }
| <"\\t"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\t');
  }
| <"\\" ("x"|"X") ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]> {
      l = image.length();
      byte b = BaseUtil.parseHexByte(image.charAt(l-2), image.charAt(l-1));
      image.setLength(l-3);
      image.setCharAt(l-4, (char)(b & 0xff));
  }
| <"\\" ("u"|"U") ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]> {
      l = image.length();
      char c = BaseUtil.parseUnicode(image.charAt(l-4), image.charAt(l-3), image.charAt(l-2), image.charAt(l-1));
      image.setLength(l-5);
      image.setCharAt(l-6, c);
  }
| <~["\\", "\n","\r"]>
}

SKIP :
{
  "/*" : WithinComment
| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

<WithinComment> SKIP :
{
  "*/" : DEFAULT
}

<WithinComment> MORE :
{
  <~[]>
}


//  syntax BNF:
//  TopVal    ::= JsonVal
//  JsonVal    ::= MapVal | ArrayVal | AtomVal
//  MapVal    ::= { MapFields }
//  MapFields ::= Field_name : TopVal (, MapFields)*
//  ArrayVal  ::= [ ArrayItems ]
//  ArrayItems::= TopVal (, ArrayItems)*
//  AtomVal   ::= <strvalue> | <long> | <decimal>
//
// This parser can be used in the following ways:
//
// 1) To parse a single JSON value, which is placed all in memory:
//
//        JsonValue value = parser.JsonVal();
//        parser.Eof(); // optional EOF check
//
// 2) To parse a single JSON value and do the EOF check in one call (same as above):
//
//       JsonValue value = parser.TopVal();
// 
// 3) To parse a top-level array of JSON values, one at a time
//
//        for( JsonValue value = parser.ArrayFirst() ; value != JsonParser.NIL ; value = parser.ArrayNext() )  
//        {
//           // process value
//        }
//        parser.Eof(); // optional EOF check
//
//    Note: The parser keeps only one value in memory at a time, but a new value is returned
//    each time so it is safe to keep a handle on prior values.
//
// If you want to ensure that the entire buffer was processed, parser.Eof() can be called
// after JsonVal() or when ArrayFirst()/ArrayNext() returns null.  


JsonValue JsonVal() :
{
    JsonValue value;
}
{
    ( value=ArrayVal()
    | value=MapVal() 
    | value=AtomVal()
    )
    { return value; }
}

void Eof() :
{
}
{
    <EOF>
}


JsonValue TopVal() :
{
    JsonValue value;
}
{
    value=JsonVal() Eof()
    { return value; }
}


JsonValue ArrayFirst() :
{
    JsonValue value = JsonParser.NIL;
}
{
    <ARRAY_BEGIN> (value=JsonVal())?        
    { return value; }
}

JsonValue ArrayNext() :
{
    JsonValue value;
}
{
    ( <COMMA> value=JsonVal()   { return value; }
    | <ARRAY_END>               { return JsonParser.NIL; }
    )
}

JsonValue ArrayVal() :
{
    JsonValue[] values;
}
{
    <ARRAY_BEGIN> values=ValueList() <ARRAY_END>
    { return new BufferedJsonArray(values, false); }
}

JsonValue MapVal() :
{
    BufferedJsonRecord jRecord = new BufferedJsonRecord();
}
{
    <MAP_BEGIN> 
      ( MapField(jRecord) 
        ( <COMMA> MapField(jRecord) )*
      )?
    <MAP_END>
    { return jRecord;   }
}

void MapField(BufferedJsonRecord jRecord) :
{
    String name;
    JsonValue value;
}
{
    name=Name() <COLON> value=JsonVal()
    { jRecord.add(new JsonString(name), value); }
}


String Name() :
{
    Token tok;
}
{
    tok=<ID>      { return tok.image; }
|   tok=<STRING1> { return tok.image; }
|   tok=<STRING2> { return tok.image; }
}

JsonValue AtomVal() :
{
    JsonValue value;
    Token atom;
    String s;
}
{
    ( s=String()       { value = new JsonString(s); }
    | atom=<LONG>      { value = new JsonLong(atom.image); }
    | atom=<REAL>      { value = new JsonDouble(atom.image); } // TODO: flag for double vs decimal default
    | atom=<DECIMAL>   { value = new JsonDecimal(atom.image); }
    | atom=<DOUBLE>    { value = new JsonDouble(atom.image); }
    | atom=<TRUE>      { value = JsonBool.TRUE; }
    | atom=<FALSE>     { value = JsonBool.FALSE; }
    | atom=<NULL>      { value = null; }
    | value=Construct()
    )
    { return value; }   
}

JsonValue Construct() :
{
    Token fn;
    JsonValue[] values;
}
{
    fn=<ID> <LPAREN> values=ValueList() <RPAREN>
    { return JsonConstructor.eval(fn.image, values); }
}

JsonValue[] ValueList() :
{
    ArrayList<JsonValue> values = new ArrayList<JsonValue>();
    JsonValue value;
}
{
    ( value=JsonVal()           { values.add(value); }
      ( <COMMA> value=JsonVal() { values.add(value); }
      )*
    )?
    { return values.toArray(new JsonValue[values.size()]); }
}


String String() :
{
    String str;
    String str2;
}
{
    str=String1() ( (<PLUS>)? str2=String1() { str += str2; } )*
    { return str; }
}

String String1() :
{
    Token tok;
}
{
    tok=<STRING1> { return tok.image; }
|   tok=<STRING2> { return tok.image; }
}
