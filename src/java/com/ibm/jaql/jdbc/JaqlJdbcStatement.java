/*
 * Copyright (C) IBM Corp. 2010.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.ibm.jaql.jdbc;

import com.ibm.jaql.json.schema.RecordSchema;
import com.ibm.jaql.json.schema.Schema;
import com.ibm.jaql.json.schema.SchemaTransformation;
import com.ibm.jaql.json.type.JsonString;
import com.ibm.jaql.json.type.JsonType;
import com.ibm.jaql.json.util.JsonIterator;
import com.ibm.jaql.lang.ParsedJaql;
import com.ibm.jaql.util.BaseUtil;

import java.sql.*;

public class JaqlJdbcStatement implements Statement
{
  protected JaqlJdbcConnection conn;
  protected ParsedJaql parsedJaql;

  protected String script;
  /// protected ArrayList<JaqlJdbcResultSet> results = new ArrayList<JaqlJdbcResultSet>();

  public JaqlJdbcStatement(JaqlJdbcConnection conn) throws SQLException
  {
    this.conn = conn;
  }

  @Override
  public void addBatch(String script) throws SQLException
  {
    throw new SQLFeatureNotSupportedException("batch not yet supported");
  }

  @Override
  public void cancel() throws SQLException
  {
    throw new SQLFeatureNotSupportedException("cancel not yet supported");
  }

  @Override
  public void clearBatch() throws SQLException
  {
    try
    {
      parsedJaql.close();
    }
    catch (Exception e)
    {
      throw new SQLException("while clearing batch",e);
    }
  }

  @Override
  public void clearWarnings() throws SQLException
  {
    // TODO: support warnings
  }

  @Override
  public void close() throws SQLException
  {
    clearBatch();
  }

  /**
   * Convert a jaql schema into a row schema. 
   */
  protected static RecordSchema getRowSchema(Schema schema) throws SQLException
  {
    if( schema.is(JsonType.ARRAY, JsonType.NULL).always() )
    {
      schema = schema.elements();
    }
    if( schema == null ) // empty result
    {
      schema = new RecordSchema(new JsonString[0]); // make into an empty record
    }
    else if( ! schema.is(JsonType.RECORD).always() )
    {
      throw new SQLException("jaql statement must produce records");
    }
    return (RecordSchema)SchemaTransformation.restrictTo(schema, JsonType.RECORD);
  }
  
  @Override
  public boolean execute(String script) throws SQLException
  {
    try
    {
      if( parsedJaql != null )
      {
        parsedJaql.close();
        parsedJaql = null;
      }
      this.script = script;
      conn.jaql.setInput(script);
      parsedJaql = conn.jaql.parseScript();
      parsedJaql.open();
      return parsedJaql.hasMoreResults();
//      
//      results.clear();
//      this.script = script;
//      conn.jaql.setInput(script);
//      JsonIterator iter;
//      while( (iter = conn.jaql.iter()) != null )
//      {
//        RecordSchema recSchema = getRowSchema(conn.jaql.currentSchema());
//        results.add(new JaqlJdbcResultSet(this, recSchema, iter));
//      }
//      return results.size() > 0;
    }
    catch( SQLException e )
    {
      throw e;
    }
    catch( Exception e )
    {
      // 58033  An unexpected error occurred while attempting to access a client driver.
      Throwable c = BaseUtil.getRootCause(e);
      throw new SQLException("while preparing statements: ["+c.getClass().getSimpleName()+"]"+c.getMessage(),"58033",e);
    }
  }

  @Override
  public boolean execute(String script, int autoGeneratedKeys) throws SQLException
  {
    if( autoGeneratedKeys != Statement.NO_GENERATED_KEYS )
    {
      throw new SQLFeatureNotSupportedException("autogenerated keys not supported");
    }
    return execute(script);
  }

  @Override
  public boolean execute(String script, int[] columnIndexes) throws SQLException
  {
    if( columnIndexes != null && columnIndexes.length > 0 )
    {
      throw new SQLFeatureNotSupportedException("column indexes are not supported");
    }
    return execute(script);
  }

  @Override
  public boolean execute(String script, String[] columnNames) throws SQLException
  {
    if( columnNames != null && columnNames.length > 0 )
    {
      throw new SQLFeatureNotSupportedException("column names are not supported");
    }
    return execute(script);
  }

  @Override
  public int[] executeBatch() throws SQLException
  {
    throw new SQLFeatureNotSupportedException("batch not yet supported");
  }

  @Override
  public JaqlJdbcResultSet executeQuery(String script) throws SQLException
  {
    if( ! execute(script) )
    {
      throw new SQLException("no result set");
    }
    return getResultSet();
  }

  @Override
  public int executeUpdate(String script) throws SQLException
  {
    throw new SQLFeatureNotSupportedException("update not supported");
  }

  @Override
  public int executeUpdate(String script, int autoGeneratedKeys)
      throws SQLException
  {
    throw new SQLFeatureNotSupportedException("update not supported");
  }

  @Override
  public int executeUpdate(String script, int[] columnIndexes) throws SQLException
  {
    throw new SQLFeatureNotSupportedException("update not supported");
  }

  @Override
  public int executeUpdate(String script, String[] columnNames)
      throws SQLException
  {
    throw new SQLFeatureNotSupportedException("update not supported");
  }

  @Override
  public Connection getConnection() throws SQLException
  {
    return conn;
  }

  @Override
  public int getFetchDirection() throws SQLException
  {
    return ResultSet.FETCH_FORWARD;
  }

  @Override
  public int getFetchSize() throws SQLException
  {
    return 1;
  }

  @Override
  public ResultSet getGeneratedKeys() throws SQLException
  {
    throw new SQLFeatureNotSupportedException("generated keys not supported");
  }

  @Override
  public int getMaxFieldSize() throws SQLException
  {
    return Integer.MAX_VALUE;
  }

  @Override
  public int getMaxRows() throws SQLException
  {
    return 0;
  }

  @Override
  public boolean getMoreResults() throws SQLException
  {
    try
    {
      return parsedJaql != null && parsedJaql.hasMoreResults();
    }
    catch( Exception e )
    {
      // 58033  An unexpected error occurred while attempting to access a client driver.
      Throwable c = BaseUtil.getRootCause(e);
      throw new SQLException("while checking for more results: ["+c.getClass().getSimpleName()+"]"+c.getMessage(),"58033",e);
    }
  }

  @Override
  public boolean getMoreResults(int current) throws SQLException
  {
//    if( current != Statement.CLOSE_CURRENT_RESULT && 
//        current != Statement.CLOSE_ALL_RESULTS )
//    {
//      throw new SQLFeatureNotSupportedException("results");
//    }
    return getMoreResults();
  }

  @Override
  public int getQueryTimeout() throws SQLException
  {
    return 0;
  }

  @Override
  public JaqlJdbcResultSet getResultSet() throws SQLException
  {
    try
    {
      JsonIterator iter = parsedJaql.iter();
      RecordSchema recSchema = getRowSchema( parsedJaql.currentSchema() );
      return new JaqlJdbcResultSet(this, recSchema, iter);
    }
    catch( SQLException e )
    {
      throw e;
    }
    catch( Exception e )
    {
      // 58033  An unexpected error occurred while attempting to access a client driver.
      Throwable c = BaseUtil.getRootCause(e);
      throw new SQLException("while running statement: ["+c.getClass().getSimpleName()+"]"+c.getMessage(),"58033",e);
    }
  }

  @Override
  public int getResultSetConcurrency() throws SQLException
  {
    return ResultSet.CONCUR_READ_ONLY;
  }

  @Override
  public int getResultSetHoldability() throws SQLException
  {
    return ResultSet.CLOSE_CURSORS_AT_COMMIT;
  }

  @Override
  public int getResultSetType() throws SQLException
  {
    return ResultSet.TYPE_FORWARD_ONLY;
  }

  @Override
  public int getUpdateCount() throws SQLException
  {
    return -1;
  }

  @Override
  public SQLWarning getWarnings() throws SQLException
  {
    return null;
  }

  @Override
  public boolean isClosed() throws SQLException
  {
    return false;
  }

  @Override
  public boolean isPoolable() throws SQLException
  {
    return false;
  }

  @Override
  public void closeOnCompletion() throws SQLException {
    // TODO Auto-generated method stub
  }

  @Override
  public boolean isCloseOnCompletion() throws SQLException {
    // TODO Auto-generated method stub
    return false;
  }

  @Override
  public void setCursorName(String name) throws SQLException
  {
    throw new SQLFeatureNotSupportedException("cursor name");
  }

  @Override
  public void setEscapeProcessing(boolean enable) throws SQLException
  {
    throw new SQLFeatureNotSupportedException("escape processing");
  }

  @Override
  public void setFetchDirection(int direction) throws SQLException
  {
    if( direction != ResultSet.FETCH_FORWARD )
    {
      throw new SQLFeatureNotSupportedException("only forward cursors are supported");
    }
  }

  @Override
  public void setFetchSize(int rows) throws SQLException
  {
  }

  @Override
  public void setMaxFieldSize(int max) throws SQLException
  {
    throw new SQLFeatureNotSupportedException("max field size");
  }

  @Override
  public void setMaxRows(int max) throws SQLException
  {
    throw new SQLFeatureNotSupportedException("max rows");
  }

  @Override
  public void setPoolable(boolean poolable) throws SQLException
  {
  }

  @Override
  public void setQueryTimeout(int seconds) throws SQLException
  {
    throw new SQLFeatureNotSupportedException("query timeout");
  }

  @Override
  public boolean isWrapperFor(Class<?> iface) throws SQLException
  {
    return false;
  }

  @Override
  public <T> T unwrap(Class<T> iface) throws SQLException
  {
    return null;
  }
}
