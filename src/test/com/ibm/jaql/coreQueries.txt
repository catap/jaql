//-------------------------- ATOMS --------------------------------
typeof([]);

typeof({});

typeof("foo");

typeof(true);

typeof(1);

1;

10.5;

15.5e-9;

d'2001-07-04T12:08:56Z';

// an invalid date format
d'12/10/1999';

'a string';

'a string
with a newline';

true;

false;

null;

//-------------------------- ARRAYS -------------------------------
[];

[ 1, 2, 3 ];

[ 'a', 2, 'c' ];

// this one caused a bug with int/long serialization
[d'2007-12-31T16:00:10Z'];

// nulls are fine elements of an array
[ 1, null, 3 ];

//-------------------------- RECORDS ------------------------------
{};

{ x: 1, y: 'b' };

// nulls are fine values of a field
{ x: 1, y: null };

// Field names must be strings or ids
{ x: 1, 3: 2 };

// every field must be named
{a: 1 ,2,3};

// a field can be specified to disappear if its value is null
{a:'foo', b?:null};

//-------------------------- NESTING ------------------------------
[[[[[[[[[[[[]]]]]]]]]]]];

[{a:'some string', b:[{},{y:1, z:42},['a', 'b']]},1,'a string',['another string']];

//-------------------------- ARITH/LOGIC OPS-----------------------
1+2;

1/2;

true or false;

true and true;

true and false;

true or null;

true and null;

false or not null;

// all values are comparable, if not by value then by their type code
'a' > {};

// comparisons are deep 
[1,2,3,{a:'foo', b:['bar']}] == [1,2,3,{a:'foo', b:['bar']}];

// make sure numeric encodings hash and compare properly
distinct( [1, 1.0, 1.1, 1.10] ) -> sort by [$]; // 2 items

1 == 1.0; // true

1 == 1.1; // false

1.1 == 1.10; // true

1.11 != 1.10; // true

// make sure array encodings hash and compare properly
distinct( [
  [1,2], 
  range(1,2) -> filter $ > 0,  // [1,2]
  [1,2,3], 
  range(1,3) -> filter $ != 2, // [1,3]
  range(1,3) -> filter $ > 0,  // [1,2,3]
  [1,3]
] ) -> sort by [$]; // 3 items

[1,2] == ( range(1,2) -> filter $ > 0 ); // true

[1,2] == ( range(1,3) -> filter $ != 2 ); // false

[1,3] == ( range(1,3) -> filter $ != 2 ); // true

[1,2] != ( range(1,3) -> filter $ > 0 ); // true

typeof([]) == "array";

typeof("foo") == "record";

//-------------------------- CONDITIONAL --------------------------
if( true ) 1 else 'really?';

// expecting null when the false branch is empty
if( false ) 1;

//-------------------------- ARRAY OPS ----------------------------

// group by field a, returning all records in each group
group [ {a:1, b:'1x'}, {a:2, b:'2x'}, {a:1, b:'1y'}, {a:2, b:'2y'} ] 
   by $a = ($.a) as $i
 into { a:$a, i:$i };

// same as above - default 'as' is input expression
$i = [ {a:1, b:'1x'}, {a:2, b:'2x'}, {a:1, b:'1y'}, {a:2, b:'2y'} ] ;
group $i by $a = ($.a) into { a:$a, i:$i };

// same as above - default 'as' is $
[ {a:1, b:'1x'}, {a:2, b:'2x'}, {a:1, b:'1y'}, {a:2, b:'2y'} ] 
-> group by $a = ($.a) into { a:$a, i:$ };

// group by field a, returning b's from each group
group [ {a:1, b:'1x'}, {a:2, b:'2x'}, {a:1, b:'1y'}, {a:2, b:'2y'} ] 
   by $a = ($.a) as $i
 into { a:$a, bs: $i[*].b };

// Count each distinct value
group [ 1, 1, 1, 2, 2, 3, 3, 3, 3 ] 
   by $unique = ($) as $i
   into { val: $unique, n: count($i) };

// List distinct values
group [ 1, 1, 1, 2, 2, 3, 3, 3, 3 ] 
   by $unique = ($) as $i
   into $unique;

// Count how many evens and odds - use explicit input variable name
group each $i in [ 1, 1, 1, 2, 2, 3, 3, 3, 3 ] 
   by $g = (mod($i,2)) as $j
   into { val: $g, n: count($j) };

// cogroup (generalizes inner/outer join for equality predicates)
group
  [ {a:1, b:'b1x'}, {a:2, b:'b2x'}, {a:3, b:'b3x'}, {a:1, b:'b1y'}, {a:2, b:'b2y'} ] 
     by $g = ($.a) as $i,
  [ {c:1, d:'d1x'}, {c:2, d:'d2x'}, {c:4, d:'d4x'}, {c:1, d:'d1y'}, {c:2, d:'d2y'} ]
     by $g = ($.c) as $j
  into { g:$g, bs:$i[*].b, ds:$j[*].d };

// This will generate a semantic error because the 'by' names must be unique.
group
  [] by $g = ($.a) as $is,
  [] by $h = ($.c) as $js,
  into { g:$g, bs:$is[*].b, ds:$js[*].d };


[ {a:1, b:'1x'}, {a:2, b:'2x'}, {a:1, b:'1y'}, {a:2, b:'2y'} ] 
-> sort by [$.a];

[ {a:2, b:1}, {a:1, b:2}, {a:2, b:2}, {a:1, b:1} ] 
-> sort by [$.a, $.b];

[ {a:2, b:1}, {a:1, b:2}, {a:2, b:2}, {a:1, b:1} ] 
-> sort by [$.b, $.a];

[ {a:2, b:1}, {a:1, b:2}, {a:2, b:2}, {a:1, b:1} ] 
-> sort by [ $ ];

range(1,10000) -> transform {x: [-$,$]} -> top 1 by [$];
range(1,1000) -> top 1 by [{x:[-$,$],y:[$,$]}];
range(1,1000) -> top 1 by [-$,$];
range(1,100) -> top 1 by [{x:[-$,$]}];

//-------------------------- RECORD OPS ---------------------------

$pivot = (
   -> transform { $.label: $.value }
   -> record()
   // -> combine( fn($a,$b) remap( $a, $b ) )
);

$input = [ { label: "name", value: "joe" },
           { label: "work", value: "acme plumbing" },
           { label: "office", value: "b1" } ];

$input -> $pivot();

//-------------------------- LET ---------------------------------

( $r = { x:1, y:2 },

  { $r.x, z: $r.y, t: $r.x+$r.y, $r.nope } );

( $r = { x:1, y:2 },
  $s = {z:3},

  [ $r, $s ] );

( $r = 1,
  $r = ( $r = $r + 10, // 11
         $r + 100 ) // 111
       + $r, // 112
  $r );

//-------------------------- EXPAND ---------------------------------

[ {x:[{a:1},{a:2}], y:2}, {y:3}, {x:[{a:1}]} ]
-> expand $.x;

[ {x:[{a:1},{a:2}], y:2}, {y:3}, {x:[{a:1}]} ]
-> expand [ $.x ];

[ {x:[{a:1},{a:2}], y:2}, {y:3}, {x:[{a:1}]} ]
-> expand $.x
-> transform $.a;

//-------------------------- JOIN ---------------------------------

equijoin $i in [ 1, 2, 3 ] on ($i),
         $j in [ 1, 2, 4 ] on ($j) 
into {$i, $j};

equijoin          $i in [ 1, 2, 3 ] on $i,
         preserve $j in [ 1, 2, 4 ] on $j
into {$i, $j};

equijoin preserve $i in [ 1, 2, 3 ] on $i,
                  $j in [ 1, 2, 4 ] on $j
into {$i, $j};

equijoin preserve $i in [ 1, 2, 3 ] on $i,
         preserve $j in [ 1, 2, 4 ] on $j
into {$i, $j};

join $i in [ 1, 2, 3 ],
     $j in [ 1, 2, 4 ]
where $i == $j
into {$i, $j};

join          $i in [ 1, 2, 3 ],
     preserve $j in [ 1, 2, 4 ]
where $i == $j
into {$i, $j};

join preserve $i in [ 1, 2, 3 ],
              $j in [ 1, 2, 4 ]
where $i == $j
into {$i, $j};

join preserve $i in [ 1, 2, 3 ],
     preserve $j in [ 1, 2, 4 ]
where $i == $j
into {$i, $j};

//-------------------------- QUIT ---------------------------------

quit;

