
;//------------------- TEST-CASE -----------------
//===========================================================================
// Testcases for FilterPushDown
// It tests pushing Filter below Transform, Join, Group By, Sort, Merge
// It handles predicate decomposition (Dividing Filter predicates into conjunctive sub-predicates)  
//===========================================================================

$data_books = [
    {publisher: 'Scholastic',
     author: 'J. K. Rowling',
     title: 'Deathly Hallows',
     year: 2007,
     format: {cover: 'hard', pages: 1302},
     price: [3, 34.0, 102222, 3.3]},

    {publisher: 'Scholastic',
     author: 'J. K. Rowling',
     title: 'Chamber of Secrets',
     year: 1999, 
     format: {cover: 'hard', pages: 1302}},

    {publisher: 'XYZ',
     author: 'J. K. Rowling',
     title: 'Deathly Hallows',
     year: 1998,
      format: {cover: 'soft', pages: 1200},
     price: [120.5, 110.0]},

    {publisher: 'Ray ST',
     author: 'New Rowling',
     title: 'Chamber of Secrets',
     year: 1998, 
     reviews: [{rating: 10, user: 'joe', review: 'The best ...'}]},

    {publisher: 'Scholastic',
     author: 'J. K. Rowling',
     title: 'Sorcerers Stone',
     year: 1996,
     format: {cover: 'hard', pages: 742},
     price: [11.0, 17.5]},

    {publisher: 'Scholastic',
     author: 'R. L. Stine',
     title: 'Monster Blood IV',
     year: 1995, 
     format: {cover: 'soft', pages: 302}},

    {publisher: 'Grosset',
     author: 'Carolyn Keene',
     title: 'The Secret of Kane',
     year: 1988},
     
     
     {publisher: 'Scholastic',
          author: 'J. K. Rowling',
          title: 'Deathly Hallows',
          year: 1987},
     
         {publisher: 'Scholastic',
          author: 'J. K. Rowling',
          title: 'Chamber of Secrets',
          year: 1987, 
          reviews: [
            {rating: 10, user: 'joe', review: 'The best ...'},
            {rating: 6, user: 'mary', review: 'Average ...'}]},
     
         {publisher: 'XYZ',
          author: 'J. K. Rowling',
          title: 'Deathly Hallows',
          year: 1986},
     
         {publisher: 'Foster',
          author: 'Old Rowling',
          title: 'Chamber of Secrets',
          year: 1979, 
          reviews: [{rating: 10, user: 'joe', review: 'The best ...'}]},
     
         {publisher: 'Scholastic',
          author: 'J. K. Rowling',
          title: 'Sorcerers Stone',
          year: 1978},
     
         {publisher: 'Scholastic',
          author: 'R. L. Stine',
          title: 'Monster Blood IV',
          year: 1977, 
          price: [3.6, 20.5, 41.0]
          },
     
         {publisher: 'Grosset',
          author: 'Carolyn Keene',
          title: 'The Secret of Kane',
          year: 1920,
          format: {cover: 'hard', pages: 66}}
];
;//------------------- TEST-CASE -----------------



$data_books2 = [
    {publisher: 'Scholastic',
     author: 'J. K. Rowling',
     title: 'Deathly Hallows',
     year: 2007,
     format: {cover: 'hard', pages: 1302},
     price: [30.5, 33.5, 34.0]},

    {publisher: 'Scholastic',
     author: 'J. K. Rowling',
     title: 'Chamber of Secrets',
     year: 1999, 
     format: {cover: 'hard', pages: 1302},
     price: [20.1, 25.0]
     },

    {publisher: 'XYZ',
     author: 'J. K. Rowling',
     title: 'Deathly Hallows',
     year: 1998,
      format: {cover: 'soft', pages: 1200},
    price: [120.5, 110.0]},

    {publisher: 'Scholastic',
     author: 'J. K. Rowling',
     title: 'Sorcerers Stone',
     year: 1996,
     format: {cover: 'hard', pages: 742},
     price: [11.0, 17.5]},

    {publisher: 'Scholastic',
     author: 'R. L. Stine',
     title: 'Monster Blood IV',
     year: 1995, 
     format: {cover: 'soft', pages: 302}},

    {publisher: 'Grosset',
     author: 'Carolyn Keene',
     title: 'The Secret of Kane',
     year: 1988},
     
     
     {publisher: 'Scholastic',
          author: 'J. K. Rowling',
          title: 'Deathly Hallows',
          year: 1987},
     
         {publisher: 'Scholastic',
          author: 'J. K. Rowling',
          title: 'Chamber of Secrets',
          year: 1987, 
          reviews: [
            {rating: 10, user: 'joe', review: 'The best ...'},
            {rating: 6, user: 'mary', review: 'Average ...'}]},
     
         {publisher: 'XYZ',
          author: 'J. K. Rowling',
          title: 'Deathly Hallows',
          year: 1986},
     
         {publisher: 'Foster',
          author: 'Old Rowling',
          title: 'Chamber of Secrets',
          year: 1979, 
          reviews: [{rating: 10, user: 'joe', review: 'The best ...'}]},
     
         {publisher: 'Scholastic',
          author: 'J. K. Rowling',
          title: 'Sorcerers Stone',
          year: 1978},
     
         {publisher: 'Scholastic',
          author: 'R. L. Stine',
          title: 'Monster Blood IV',
          year: 1977,
          price: [3.6, 20.5, 41.0]
          },
     
         {publisher: 'Grosset',
          author: 'Carolyn Keene',
          title: 'The Secret of Kane',
          year: 1920,
          format: {cover: 'hard', pages: 66}}   
];
;//------------------- TEST-CASE -----------------



//=========================Testing Filter-Transform===================================================

//Returns 8 records  --Should be pusheddown 
$data_books -> transform {x: $.author, $.year} -> filter $.x == 'J. K. Rowling';

;//--------------------- RESULT ------------------

[
  {
    "x": "J. K. Rowling",
    "year": 2007
  },
  {
    "x": "J. K. Rowling",
    "year": 1999
  },
  {
    "x": "J. K. Rowling",
    "year": 1998
  },
  {
    "x": "J. K. Rowling",
    "year": 1996
  },
  {
    "x": "J. K. Rowling",
    "year": 1987
  },
  {
    "x": "J. K. Rowling",
    "year": 1987
  },
  {
    "x": "J. K. Rowling",
    "year": 1986
  },
  {
    "x": "J. K. Rowling",
    "year": 1978
  }
]

;//------------------- TEST-CASE -----------------
     

//Returns count of 14 records  --Should be pusheddown TWICE
$data_books -> transform each $d {x: $d.author, $d.format.cover, y:$d.price} -> transform each $g [$g.x, $g.y] -> filter true ->count();

;//--------------------- RESULT ------------------

14

;//------------------- TEST-CASE -----------------



//Returns count of 3 records  --Should be pusheddown (All the three predicates)
$data_books -> transform {n: $.author, x: $, $.year , $.format.cover, $, c: $.format.cover, f: $.price-> count(), k: "33333"} -> filter each $dd $dd.cover == 'hard' and $dd.k == '33333' and $dd."".author == 'J. K. Rowling' -> count();

;//--------------------- RESULT ------------------

3

;//------------------- TEST-CASE -----------------
  

//Returns count of 2 records  --(Predicates 1, 2, and 4 should be pusheddown) (Predicate 3 stays as is)
$data_books -> transform {n: $.author, x: $, $.year , $.format.cover, $, c: $.format.cover, f: $.price-> count(), k: "33333"} -> filter $.cover == 'hard' and $.k == '33333' and $.f > 1 and $."".author == 'J. K. Rowling' -> count() ;

;//--------------------- RESULT ------------------

2

;//------------------- TEST-CASE -----------------
  

//Returns 3 records  --Should be pusheddown
$data_books -> transform each $d {n: $d.author, m: $d.year, $d.year , c: $d.format} -> filter  each $x $x.m >= 2004 or $x.c.cover == 'soft';

;//--------------------- RESULT ------------------

[
  {
    "c": {
      "cover": "hard",
      "pages": 1302
    },
    "m": 2007,
    "n": "J. K. Rowling",
    "year": 2007
  },
  {
    "c": {
      "cover": "soft",
      "pages": 1200
    },
    "m": 1998,
    "n": "J. K. Rowling",
    "year": 1998
  },
  {
    "c": {
      "cover": "soft",
      "pages": 302
    },
    "m": 1995,
    "n": "R. L. Stine",
    "year": 1995
  }
]

;//------------------- TEST-CASE -----------------
 

//Returns 6 records  --Should be pusheddown  
$data_books -> transform ($.year) -> filter $ > 1990;

;//--------------------- RESULT ------------------

[
  2007,
  1999,
  1998,
  1998,
  1996,
  1995
]

;//------------------- TEST-CASE -----------------



//Returns 4 records  --Should be pusheddown  
$data_books -> transform ($.format) -> filter $.cover == 'hard';

;//--------------------- RESULT ------------------

[
  {
    "cover": "hard",
    "pages": 1302
  },
  {
    "cover": "hard",
    "pages": 1302
  },
  {
    "cover": "hard",
    "pages": 742
  },
  {
    "cover": "hard",
    "pages": 66
  }
]

;//------------------- TEST-CASE -----------------



//Returns 4 records  --Should be pusheddown  
$data_books -> transform {$.author, cnt: $.year + $.format.pages * 2} -> filter each $x $x.cnt > 3000;

;//--------------------- RESULT ------------------

[
  {
    "author": "J. K. Rowling",
    "cnt": 4611
  },
  {
    "author": "J. K. Rowling",
    "cnt": 4603
  },
  {
    "author": "J. K. Rowling",
    "cnt": 4398
  },
  {
    "author": "J. K. Rowling",
    "cnt": 3480
  }
]

;//------------------- TEST-CASE -----------------



//Returns 2 records  --Should be pusheddown TWICE
$data_books -> transform each $d {x: $d.author, $d.format.cover, y:$d.price} -> transform each $g [$g.x, $g.y] -> filter $[0] == 'R. L. Stine';

;//--------------------- RESULT ------------------

[
  [
    "R. L. Stine",
    null
  ],
  [
    "R. L. Stine",
    [
      3.6,
      20.5,
      41.0
    ]
  ]
]

;//------------------- TEST-CASE -----------------


//Returns 1 record  --First predicate should be pushed TWICE. The second predicate should be pusheddown ONCE
$data_books -> transform each $d {x: $d.author, $d.format.cover, y:sum($d.price)} -> transform each $g [$g.x, $g.y] -> filter $[0] == 'R. L. Stine' and $[1]> 20;

;//--------------------- RESULT ------------------

[
  [
    "R. L. Stine",
    65.1
  ]
]

;//------------------- TEST-CASE -----------------



//Returns 4 records  --Should be pusheddown ONCE
$data_books -> transform [$, $.author, $.format, "3333" ,{name: $.publisher, y: $.year}, max($.price)] -> transform {c:$[2].cover, $[4].name, max: $[5] } -> filter $.max > 2;

;//--------------------- RESULT ------------------

[
  {
    "c": "hard",
    "max": 102222,
    "name": "Scholastic"
  },
  {
    "c": "soft",
    "max": 120.5,
    "name": "XYZ"
  },
  {
    "c": "hard",
    "max": 17.5,
    "name": "Scholastic"
  },
  {
    "c": null,
    "max": 41.0,
    "name": "Scholastic"
  }
]

;//------------------- TEST-CASE -----------------



//Returns 2 records  --Should be pusheddown TWICE
$data_books -> transform [$, $.author, $.format, "3333" ,{name: $.publisher, y: $.year}, max($.price)] -> transform {c:$[2].cover, $[4].name, max: $[5] } -> filter $.c == 'soft';

;//--------------------- RESULT ------------------

[
  {
    "c": "soft",
    "max": 120.5,
    "name": "XYZ"
  },
  {
    "c": "soft",
    "max": null,
    "name": "Scholastic"
  }
]

;//------------------- TEST-CASE -----------------


//Returns 2 records  --Should be pusheddown TWICE
$data_books -> transform each $d {x: $d.author, $d.format.cover, y:$d.price} -> transform each $g [$g.x, $g.y] -> filter count($[1]) > 2;

;//--------------------- RESULT ------------------

[
  [
    "J. K. Rowling",
    [
      3,
      34.0,
      102222,
      3.3
    ]
  ],
  [
    "R. L. Stine",
    [
      3.6,
      20.5,
      41.0
    ]
  ]
]

;//------------------- TEST-CASE -----------------



//Returns 1 record --(Predicate $.a == 1 should be pushed down.
//                    Predicate count($.less)>4 remains as is).
[{a:1, b:[1,2,3,4,5,6,6,77,87,43,122]}, {a:2, b:[12,3,34434,766,33,11,10,2]}] -> 
	transform{$.a, less: $.b -> filter $ <100, more:$.b -> filter $ >= 100 } -> filter $.a == 1 and count($.less) > 4;

;//--------------------- RESULT ------------------

[
  {
    "a": 1,
    "less": [
      1,
      2,
      3,
      4,
      5,
      6,
      6,
      77,
      87,
      43
    ],
    "more": [
      122
    ]
  }
]

;//------------------- TEST-CASE -----------------


//Returns 1 record --(Filter should be pushed below Transform)
[true,false] -> transform [1,$] -> filter $[1];

;//--------------------- RESULT ------------------

[
  [
    1,
    true
  ]
]

;//------------------- TEST-CASE -----------------


//Returns 1 record --(Filter should be pushed below Transform)
[true,false] -> transform {a:1 ,b:$} -> filter $.b;

;//--------------------- RESULT ------------------

[
  {
    "a": 1,
    "b": true
  }
]

;//------------------- TEST-CASE -----------------


//====================Testing Filter-Transform-Join===================================================
//Returns 0 records. --(Filter should be pushed down all the way in BOTH directions)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter false;

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------



//Returns count of 8 records. --(Both predicates should be pushed down all the way in ONE direction)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m == 2007 -> count();

;//--------------------- RESULT ------------------

8

;//------------------- TEST-CASE -----------------



//Returns count of  8 records. --(Both predicates should be pushed down all the way in ONE direction)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m == 2007 and $.r1.m == $.r1.year -> count();

;//--------------------- RESULT ------------------

8

;//------------------- TEST-CASE -----------------



//Returns 2 records --(Predicate $.a ==  'soft' should be pushed after the first Transform
//                     Predicate $.b > 1990 should be pushed below the second Transform)     
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2 -> transform {x: $.author, w:$.year};
;//------------------- TEST-CASE -----------------

join $r1, $r2 where $r1.n == $r2.x and $r1.m == $r2.w into {a: $r1.c, b: $r2.w} -> filter $.a ==  'soft' and $.b > 1990;

;//--------------------- RESULT ------------------

[
  {
    "a": "soft",
    "b": 1998
  },
  {
    "a": "soft",
    "b": 1995
  }
]

;//------------------- TEST-CASE -----------------




//Returns 5 records --(Predicates are pushed down only before the INTO clause but not before the join)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2 -> transform {x: $.author, w:$.year};
;//------------------- TEST-CASE -----------------

join $r1, $r2 where $r1.n == $r2.x and $r1.m == $r2.w into {a: $r1.c, b: $r2.w} -> filter $.a ==  'soft' or $.b > 1990;

;//--------------------- RESULT ------------------

[
  {
    "a": "hard",
    "b": 1999
  },
  {
    "a": "hard",
    "b": 1996
  },
  {
    "a": "soft",
    "b": 1998
  },
  {
    "a": "hard",
    "b": 2007
  },
  {
    "a": "soft",
    "b": 1995
  }
]

;//------------------- TEST-CASE -----------------




//Returns 2 records --(Predicate $.a ==  'soft' should be pushed after the first Transform
//                     Predicate $.d2 == $.d3 should be pushed down only before the INTO clause but not before the join)     
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2 -> transform {x: $.author, w:$.year};
;//------------------- TEST-CASE -----------------

join $r1, $r2 where $r1.n == $r2.x and $r1.m == $r2.w into {d1: $r1.c, d2: $r2.w, d3: $r1.year} -> filter $.d1 ==  'soft' and $.d2 == $.d3;

;//--------------------- RESULT ------------------

[
  {
    "d1": "soft",
    "d2": 1998,
    "d3": 1998
  },
  {
    "d1": "soft",
    "d2": 1995,
    "d3": 1995
  }
]

;//------------------- TEST-CASE -----------------


//Returns 8 records --(Predicates are pushed down only before the INTO clause but not before the join)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

join preserve $r1, preserve $r2 where $r1.n == $r2.author into {$r1, $r2} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m == 2007;

;//--------------------- RESULT ------------------

[
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "format": {
        "cover": "hard",
        "pages": 1302
      },
      "price": [
        30.5,
        33.5,
        34.0
      ],
      "publisher": "Scholastic",
      "title": "Deathly Hallows",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "format": {
        "cover": "hard",
        "pages": 1302
      },
      "price": [
        20.1,
        25.0
      ],
      "publisher": "Scholastic",
      "title": "Chamber of Secrets",
      "year": 1999
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "format": {
        "cover": "soft",
        "pages": 1200
      },
      "price": [
        120.5,
        110.0
      ],
      "publisher": "XYZ",
      "title": "Deathly Hallows",
      "year": 1998
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "format": {
        "cover": "hard",
        "pages": 742
      },
      "price": [
        11.0,
        17.5
      ],
      "publisher": "Scholastic",
      "title": "Sorcerers Stone",
      "year": 1996
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "publisher": "Scholastic",
      "title": "Deathly Hallows",
      "year": 1987
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "publisher": "Scholastic",
      "reviews": [
        {
          "rating": 10,
          "review": "The best ...",
          "user": "joe"
        },
        {
          "rating": 6,
          "review": "Average ...",
          "user": "mary"
        }
      ],
      "title": "Chamber of Secrets",
      "year": 1987
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "publisher": "XYZ",
      "title": "Deathly Hallows",
      "year": 1986
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "publisher": "Scholastic",
      "title": "Sorcerers Stone",
      "year": 1978
    }
  }
]

;//------------------- TEST-CASE -----------------



//Returns 8 records --(Predicates 1 & 2 are pushed down only before the INTO clause but not before the join,
//                     Predicate 3 is pushed down all the way in BOTH sides)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

join $r1, preserve $r2 where $r1.n == $r2.author into {$r1, $r2} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m == 2007  and true;

;//--------------------- RESULT ------------------

[
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "format": {
        "cover": "hard",
        "pages": 1302
      },
      "price": [
        30.5,
        33.5,
        34.0
      ],
      "publisher": "Scholastic",
      "title": "Deathly Hallows",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "format": {
        "cover": "hard",
        "pages": 1302
      },
      "price": [
        20.1,
        25.0
      ],
      "publisher": "Scholastic",
      "title": "Chamber of Secrets",
      "year": 1999
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "format": {
        "cover": "soft",
        "pages": 1200
      },
      "price": [
        120.5,
        110.0
      ],
      "publisher": "XYZ",
      "title": "Deathly Hallows",
      "year": 1998
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "format": {
        "cover": "hard",
        "pages": 742
      },
      "price": [
        11.0,
        17.5
      ],
      "publisher": "Scholastic",
      "title": "Sorcerers Stone",
      "year": 1996
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "publisher": "Scholastic",
      "title": "Deathly Hallows",
      "year": 1987
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "publisher": "Scholastic",
      "reviews": [
        {
          "rating": 10,
          "review": "The best ...",
          "user": "joe"
        },
        {
          "rating": 6,
          "review": "Average ...",
          "user": "mary"
        }
      ],
      "title": "Chamber of Secrets",
      "year": 1987
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "publisher": "XYZ",
      "title": "Deathly Hallows",
      "year": 1986
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    },
    "r2": {
      "author": "J. K. Rowling",
      "publisher": "Scholastic",
      "title": "Sorcerers Stone",
      "year": 1978
    }
  }
]

;//------------------- TEST-CASE -----------------



//Returns 8 records --(Predicates are pushed down all the way in ONE side)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

join preserve $r1,  $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m == 2007;

;//--------------------- RESULT ------------------

[
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  }
]

;//------------------- TEST-CASE -----------------


//Returns count of 8 records --(Predicate ($.author == 'R. L. Stine') is pushed all the way to $r1 side,
//                              Predicate ($.x == 'R. L. Stine') is pushed all the way to $r3 side,
//                              Predicate ($.z > 2400) is pushed all the way to $r4 side)
$r1 = $data_books;
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

$r3 = $data_books -> transform {x: $.author, y: $.year * 2};
;//------------------- TEST-CASE -----------------

$r4 = $data_books2 -> transform {w: $.author, z: $.year * 2};
;//------------------- TEST-CASE -----------------

join $r1, $r2, $r3, $r4 where $r1.author == $r2.author and $r1.author == $r3.x and $r3.y == $r4.z 
			into {$r1.author, $r2.year, $r3.x, $r4.w, $r4.z} -> filter $.author == 'R. L. Stine' and 
										   $.x == 'R. L. Stine' and 
										   $.z > 2400 -> count();

;//--------------------- RESULT ------------------

8

;//------------------- TEST-CASE -----------------



//Returns 1 record --(Predicates below the join should be pushed all the way before the Transform in $r1,
//                    Predicates ($[0] == 1) and ($[1][0] == 'hard') should be pushed before their Transform,
//                    Predicate count($[2]) > 4  remains as is
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

$r3 = join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m == 2007 -> top 1 -> transform ($.r1.c);
;//------------------- TEST-CASE -----------------

[{a:1, b:[1,2,3,4,5,6,6,77,87,43,122]}, {a:2, b:[12,3,34434,766,33,11,10,2]}] -> 
	transform[$.a, $r3 , $.b -> filter $ <100, $.b -> filter $ >= 100] -> filter $[0] == 1 and count($[2]) > 4 and $[1][0] == 'hard';

;//--------------------- RESULT ------------------

[
  [
    1,
    [
      "hard"
    ],
    [
      1,
      2,
      3,
      4,
      5,
      6,
      6,
      77,
      87,
      43
    ],
    [
      122
    ]
  ]
]

;//------------------- TEST-CASE -----------------



//Returns 1 record --(Predicates below the join should be pushed all the way before the join,
//                    Predicate ($[0] == 1) should be pushed before its Transform,
//                    Predicates (count($[2]) > 4) and ($[1][0] == 'hard')  remain as is
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

[{a:1, b:[1,2,3,4,5,6,6,77,87,43,122]}, {a:2, b:[12,3,34434,766,33,11,10,2]}] -> 
	transform[$.a, join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m == 2007 -> top 1 -> transform ($.r1.c) , $.b -> filter $ <100, $.b -> filter $ >= 100] -> filter $[0] == 1 and count($[2]) > 4 and $[1][0] == 'hard';

;//--------------------- RESULT ------------------

[
  [
    1,
    [
      "hard"
    ],
    [
      1,
      2,
      3,
      4,
      5,
      6,
      6,
      77,
      87,
      43
    ],
    [
      122
    ]
  ]
]

;//------------------- TEST-CASE -----------------



//===================Testing Filter-Transform-Join-Sort===================================================

//Returns 8 records  --Should be pusheddown all the way
$data_books -> transform {x: $.author, $.year} -> sort by [$.x, $.year asc] -> filter $.x == 'J. K. Rowling';

;//--------------------- RESULT ------------------

[
  {
    "x": "J. K. Rowling",
    "year": 1978
  },
  {
    "x": "J. K. Rowling",
    "year": 1986
  },
  {
    "x": "J. K. Rowling",
    "year": 1987
  },
  {
    "x": "J. K. Rowling",
    "year": 1987
  },
  {
    "x": "J. K. Rowling",
    "year": 1996
  },
  {
    "x": "J. K. Rowling",
    "year": 1998
  },
  {
    "x": "J. K. Rowling",
    "year": 1999
  },
  {
    "x": "J. K. Rowling",
    "year": 2007
  }
]

;//------------------- TEST-CASE -----------------
     

//Returns 2 records  --Should be pusheddown all the way
$data_books -> transform each $d {x: $d.author, $d.format.cover, y:$d.price} -> transform each $g [$g.x, $g.y] -> sort by [$[1]] -> filter $[0] == 'R. L. Stine';

;//--------------------- RESULT ------------------

[
  [
    "R. L. Stine",
    null
  ],
  [
    "R. L. Stine",
    [
      3.6,
      20.5,
      41.0
    ]
  ]
]

;//------------------- TEST-CASE -----------------


//Returns 1 record  --First predicate should be pushed FOUR TIMES (all the way down). The second predicate should be pusheddown THREE TIMES (after the first transform)
$data_books -> transform each $d {x: $d.author, $d.format.cover, y:sum($d.price)} -> sort by [$.y * 2] -> transform each $g [$g.x, $g.y] -> sort by [$[1]] -> filter $[0] == 'R. L. Stine' and $[1]> 20;

;//--------------------- RESULT ------------------

[
  [
    "R. L. Stine",
    65.1
  ]
]

;//------------------- TEST-CASE -----------------



//Returns 4 records  --Should be pusheddown all the way  
$data_books -> sort by [$.author] -> transform {$.author, cnt: $.year + $.format.pages * 2} -> filter each $x $x.cnt > 3000;

;//--------------------- RESULT ------------------

[
  {
    "author": "J. K. Rowling",
    "cnt": 4611
  },
  {
    "author": "J. K. Rowling",
    "cnt": 4603
  },
  {
    "author": "J. K. Rowling",
    "cnt": 4398
  },
  {
    "author": "J. K. Rowling",
    "cnt": 3480
  }
]

;//------------------- TEST-CASE -----------------



//Returns 8 records. --(Both predicates should be pushed down all the way in ONE direction)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover}  -> sort by [$.year] ;
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

join $r1, $r2 where $r1.n == $r2.author into {$r1} -> sort by [$.r1 desc] -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m == 2007;

;//--------------------- RESULT ------------------

[
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  },
  {
    "r1": {
      "c": "hard",
      "m": 2007,
      "n": "J. K. Rowling",
      "year": 2007
    }
  }
]

;//------------------- TEST-CASE -----------------



//Returns 2 records --(Predicate $.a ==  'soft' should be pushed after the first Transform
//                     Predicate $.d2 == $.d3 should be pushed down only before the INTO clause but not before the join)     
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2 -> transform {x: $.author, w:$.year} -> sort by [$.w * 4];
;//------------------- TEST-CASE -----------------

join $r1, $r2 where $r1.n == $r2.x and $r1.m == $r2.w into {d1: $r1.c, d2: $r2.w, d3: $r1.year} -> sort by [$.d2] -> filter $.d1 ==  'soft' and $.d2 == $.d3;

;//--------------------- RESULT ------------------

[
  {
    "d1": "soft",
    "d2": 1995,
    "d3": 1995
  },
  {
    "d1": "soft",
    "d2": 1998,
    "d3": 1998
  }
]

;//------------------- TEST-CASE -----------------



//========================Testing Filter-GroupBy===================================================
//Returns 1 record --(Filter should be pushed below the GroupBy)
$data_books ->  group by v = $.author into {key: v, c: min($[*].format.cover), total: sum($[*].year)} -> filter $.key == 'New Rowling';

;//--------------------- RESULT ------------------

[
  {
    "c": null,
    "key": "New Rowling",
    "total": 1998
  }
]

;//------------------- TEST-CASE -----------------



//Returns 1 record --(Filter should be pushed below the GroupBy)
$data_books ->  group by v = {$.author, $.year} into {key: v, c: $[*].format.cover, total: sum($[*].year)} -> filter each $x $x.key.author == 'New Rowling';

;//--------------------- RESULT ------------------

[
  {
    "c": [
      null
    ],
    "key": {
      "author": "New Rowling",
      "year": 1998
    },
    "total": 1998
  }
]

;//------------------- TEST-CASE -----------------
 


//Returns 2 record --(The 1st predicate should be pushed below the GroupBy. The 2nd predicate remains as is)
$data_books ->  group by v = {n: $.author, m: $.year} into {key: v, c: $[*].format.cover, total: sum($[*].year)} -> filter $.key.n > 'New Rowling' and $.total > 1978;

;//--------------------- RESULT ------------------

[
  {
    "c": [
      null
    ],
    "key": {
      "m": 1979,
      "n": "Old Rowling"
    },
    "total": 1979
  },
  {
    "c": [
      "soft"
    ],
    "key": {
      "m": 1995,
      "n": "R. L. Stine"
    },
    "total": 1995
  }
]

;//------------------- TEST-CASE -----------------
 


//Returns 3 record --(Filter remains as is)
$data_books ->  group by v = {n: $.author, m: $.year} into {key: v, c: $[*].format.cover, total: sum($[*].year)} -> filter $.key.n == 'New Rowling' or $.total > 2000;

;//--------------------- RESULT ------------------

[
  {
    "c": [
      null
    ],
    "key": {
      "m": 1998,
      "n": "New Rowling"
    },
    "total": 1998
  },
  {
    "c": [
      null,
      null
    ],
    "key": {
      "m": 1987,
      "n": "J. K. Rowling"
    },
    "total": 3974
  },
  {
    "c": [
      "hard"
    ],
    "key": {
      "m": 2007,
      "n": "J. K. Rowling"
    },
    "total": 2007
  }
]

;//------------------- TEST-CASE -----------------
 


//Returns 2 record --(Filter should be pushed below the GroupBy)
$data_books ->  group by v = [$.author, $.year] into {key: v, c: $[*].format.cover, total: sum($[*].year)} -> filter $.key[0] == 'New Rowling' or $.key[1] == 1999;

;//--------------------- RESULT ------------------

[
  {
    "c": [
      "hard"
    ],
    "key": [
      "J. K. Rowling",
      1999
    ],
    "total": 1999
  },
  {
    "c": [
      null
    ],
    "key": [
      "New Rowling",
      1998
    ],
    "total": 1998
  }
]

;//------------------- TEST-CASE -----------------
 


//Returns 2 record --(The 1st predicate should be pushed below the GroupBy. The 2nd predicate remains as is)
$data_books ->  group by v = $.author into [v, min($[*].format.cover),  sum($[*].year)] -> filter $[0] > 'A' and $[1] != 'soft';

;//--------------------- RESULT ------------------

[
  [
    "J. K. Rowling",
    "hard",
    15938
  ],
  [
    "Carolyn Keene",
    "hard",
    3908
  ]
]

;//------------------- TEST-CASE -----------------



//Returns 3 record --(Filter remains as is)
$data_books ->  group by v = $.author into (sum($[*].year)) -> filter $ >2000;

;//--------------------- RESULT ------------------

[
  15938,
  3972,
  3908
]

;//------------------- TEST-CASE -----------------



//Returns 7 record --(Filter should be pushed below the GroupBy)
$data_books -> transform {x: $.author, $.year} -> distinct() -> filter $.x == 'J. K. Rowling';

;//--------------------- RESULT ------------------

[
  {
    "x": "J. K. Rowling",
    "year": 1978
  },
  {
    "x": "J. K. Rowling",
    "year": 1999
  },
  {
    "x": "J. K. Rowling",
    "year": 2007
  },
  {
    "x": "J. K. Rowling",
    "year": 1996
  },
  {
    "x": "J. K. Rowling",
    "year": 1986
  },
  {
    "x": "J. K. Rowling",
    "year": 1987
  },
  {
    "x": "J. K. Rowling",
    "year": 1998
  }
]

;//------------------- TEST-CASE -----------------
     


//Returns 2 record --(Filter should be pushed below the GroupBy and the Transform)
$data_books -> transform each $d {n: $d.author, m: $d.year, $d.year , c: $d.format} -> group by v = [$.n, $.m] into {key: v, cover: $[*].c.cover, Min: min($[*].year)} -> filter $.key[0] == 'New Rowling' or $.key[1] > 2005;

;//--------------------- RESULT ------------------

[
  {
    "Min": 2007,
    "cover": [
      "hard"
    ],
    "key": [
      "J. K. Rowling",
      2007
    ]
  },
  {
    "Min": 1998,
    "cover": [
      null
    ],
    "key": [
      "New Rowling",
      1998
    ]
  }
]

;//------------------- TEST-CASE -----------------
 


//Returns 1 record --(1st Predicate should be pushed below the Transform. 2nd Predicate remains as is)
$data_books -> transform each $d {n: $d.author, m: $d.year, $d.year , c: $d.format} -> group by v = [$.n, $.m] into {key: v, cover: $[*].c.cover, Min: min($[*].year)} -> filter $.key[0] == 'New Rowling' and $.Min == 1998;

;//--------------------- RESULT ------------------

[
  {
    "Min": 1998,
    "cover": [
      null
    ],
    "key": [
      "New Rowling",
      1998
    ]
  }
]

;//------------------- TEST-CASE -----------------
 


//Returns 5 record --(Predicates "$.r1.n ==  'J. K. Rowling' and $.r1.m > 200" should be pushed down below the Join,
//                      Predicate $.Key < 1999 should be pushed down below the GroupBy and Join,
//                      Predicate $.Min == 'J. K. Rowling' should remain as is)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

K = join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m > 200;
;//------------------- TEST-CASE -----------------

K -> group by v = $.r1.year into {Key:v, Min: min($[*].r1.n)} -> filter $.Key < 1999 and $.Min == 'J. K. Rowling';

;//--------------------- RESULT ------------------

[
  {
    "Key": 1986,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1998,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1978,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1987,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1996,
    "Min": "J. K. Rowling"
  }
]

;//------------------- TEST-CASE -----------------



//Returns 2 record --(Predicates "$.r1.n ==  'J. K. Rowling' and $.r1.m > 200" should be pushed down below the Join,
//                      Predicate $.Key[0] < 1999 should be pushed down below the GroupBy and Join,
//                      Predicate ($.Min == 'soft' or $.Min == 'hard') should remain as is)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

$r3 = join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m > 200;
;//------------------- TEST-CASE -----------------

$r3 -> group by v = [$.r1.m, $.r1.n] into {Key:v, Min: min($[*].r1.c)} -> filter $.Key[0] < 1999 and ($.Min == 'soft' or $.Min == 'hard');

;//--------------------- RESULT ------------------

[
  {
    "Key": [
      1998,
      "J. K. Rowling"
    ],
    "Min": "soft"
  },
  {
    "Key": [
      1996,
      "J. K. Rowling"
    ],
    "Min": "hard"
  }
]

;//------------------- TEST-CASE -----------------



//Retuns 2 records --(Predicate should be pushed down in BOTH directions)
group
  [ {a:1, b:'b1x'}, {a:2, b:'b2x'}, {a:3, b:'b3x'}, {a:1, b:'b1y'}, {a:2, b:'b2y'} ] 
     by g = ($.a) as i,
  [ {c:1, d:'d1x'}, {c:2, d:'d2x'}, {c:4, d:'d4x'}, {c:1, d:'d1y'}, {c:2, d:'d2y'} ]
     by g = ($.c) as j
  into { g:g, bs:i[*].b, ds:j[*].d } -> filter $.g <= 2;

;//--------------------- RESULT ------------------

[
  {
    "bs": [
      "b2x",
      "b2y"
    ],
    "ds": [
      "d2x",
      "d2y"
    ],
    "g": 2
  },
  {
    "bs": [
      "b1x",
      "b1y"
    ],
    "ds": [
      "d1x",
      "d1y"
    ],
    "g": 1
  }
]

;//------------------- TEST-CASE -----------------

  
    
//Retuns 2 records --(Predicate should be pushed down in BOTH directions)
group
    [ {a:{x:1, y:2}, b:'b1x'}, {a:{x:2, y:4}, b:'b2x'}, {a:{x:3, y:6}, b:'b3x'}, {a:{x:1, y:6}, b:'b1y'}, {a:{x:2, y:4}, b:'b2y'} ] 
       by g = ($.a.x) as i,
    [ {c:1, d:'d1x'}, {c:2, d:'d2x'}, {c:4, d:'d4x'}, {c:1, d:'d1y'}, {c:2, d:'d2y'} ]
       by g = ($.c) as j
    into { g:g, bs:i[*].b, ds:j[*].d } -> filter $.g <= 2;

;//--------------------- RESULT ------------------

[
  {
    "bs": [
      "b2x",
      "b2y"
    ],
    "ds": [
      "d2x",
      "d2y"
    ],
    "g": 2
  },
  {
    "bs": [
      "b1x",
      "b1y"
    ],
    "ds": [
      "d1x",
      "d1y"
    ],
    "g": 1
  }
]

;//------------------- TEST-CASE -----------------

    
    
//Retuns 2 records --(Predicate remains as is)
group
    [ {a:{x:[1,10], y:2}, b:'b1x'}, {a:{x:[2,20], y:4}, b:'b2x'}, {a:{x:[3,30], y:6}, b:'b3x'}, {a:{x:[1,10], y:6}, b:'b1y'}, {a:{x:[2,20], y:4}, b:'b2y'} ] 
       by g = (min($.a.x)) as i,
    [ {c:1, d:'d1x'}, {c:2, d:'d2x'}, {c:4, d:'d4x'}, {c:1, d:'d1y'}, {c:2, d:'d2y'} ]
       by g = ($.c) as j
    into { g:g, bs:i[*].b, ds:j[*].d } -> filter $.g <= 2;

;//--------------------- RESULT ------------------

[
  {
    "bs": [
      "b2x",
      "b2y"
    ],
    "ds": [
      "d2x",
      "d2y"
    ],
    "g": 2
  },
  {
    "bs": [
      "b1x",
      "b1y"
    ],
    "ds": [
      "d1x",
      "d1y"
    ],
    "g": 1
  }
]

;//------------------- TEST-CASE -----------------

    


//Returns 5 record --(Predicates "$.r1.n ==  'J. K. Rowling' and $.r1.m > 200" should be pushed down below the Join,
//                      Predicate $.Key[0] < 1999 should be pushed down below the GroupBy and Join in BOTH directions)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

$r3 = join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m > 200;
;//------------------- TEST-CASE -----------------

$r4 = [{w:{year: 1996, author:'J. K. Rowling'}, z:10}, {w:{year: 1998, author:'J. K. Rowling'}, z:20}, {w:{year: 1998, author:'J. K. Rowling'}, z:30}];
;//------------------- TEST-CASE -----------------

group $r3 by v = [$.r1.m, $.r1.n] as i,
      $r4 by v = [$.w.year, $.w.author] as j
into {Key:v, Min: min(i[*].r1.c), Count: j[*].z} -> filter $.Key[0] < 1999 ;

;//--------------------- RESULT ------------------

[
  {
    "Count": [],
    "Key": [
      1986,
      "J. K. Rowling"
    ],
    "Min": null
  },
  {
    "Count": [
      20,
      30
    ],
    "Key": [
      1998,
      "J. K. Rowling"
    ],
    "Min": "soft"
  },
  {
    "Count": [],
    "Key": [
      1978,
      "J. K. Rowling"
    ],
    "Min": null
  },
  {
    "Count": [],
    "Key": [
      1987,
      "J. K. Rowling"
    ],
    "Min": null
  },
  {
    "Count": [
      10
    ],
    "Key": [
      1996,
      "J. K. Rowling"
    ],
    "Min": "hard"
  }
]

;//------------------- TEST-CASE -----------------



//Returns 5 record --(Predicates "$.r1.n ==  'J. K. Rowling' and $.r1.m > 200" should be pushed down below the Join,
//                    Predicate ($.Key[1] == 'J. K. Rowling') should be pushed down below the GroupBy and Join in BOTH directions,
//                    Predicate ($.Key[0] < 1999) should remain as is)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

$r3 = join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m > 200;
;//------------------- TEST-CASE -----------------

$r4 = [{w:{year: [1996, 2000], author:'J. K. Rowling'}, z:10}, {w:{year: [1998,2000], author:'J. K. Rowling'}, z:20}, {w:{year: [1998,2000], author:'J. K. Rowling'}, z:30}];
;//------------------- TEST-CASE -----------------

group $r3 by v = [$.r1.m, $.r1.n] as i,
      $r4 by v = [min($.w.year), $.w.author] as j
into {Key:v, Min: min(i[*].r1.c), Count: j[*].z} -> filter $.Key[0] < 1999 and $.Key[1] == 'J. K. Rowling';

;//--------------------- RESULT ------------------

[
  {
    "Count": [],
    "Key": [
      1986,
      "J. K. Rowling"
    ],
    "Min": null
  },
  {
    "Count": [
      20,
      30
    ],
    "Key": [
      1998,
      "J. K. Rowling"
    ],
    "Min": "soft"
  },
  {
    "Count": [],
    "Key": [
      1978,
      "J. K. Rowling"
    ],
    "Min": null
  },
  {
    "Count": [],
    "Key": [
      1987,
      "J. K. Rowling"
    ],
    "Min": null
  },
  {
    "Count": [
      10
    ],
    "Key": [
      1996,
      "J. K. Rowling"
    ],
    "Min": "hard"
  }
]

;//------------------- TEST-CASE -----------------



//Returns 2 records -- (Predicate ($.year > 1960) should be pushed all the way to $r1,
//                      Predicate ($.array[1] == 'b2y') should be pushed after the GroupBy,
//                      Predicate ($.grp_key == 2) should be pushed down before the GroupBy
$r1 = $data_books;
;//------------------- TEST-CASE -----------------

$r2 = group
  [ {a:1, b:'R. L. Stine'}, {a:2, b:'R. L. Stine'}, {a:3, b:'b3x'}, {a:1, b:'b1y'}, {a:2, b:'b2y'} ] 
     by g = ($.a) as i,
  [ {c:1, d:'d1x'}, {c:2, d:'d2x'}, {c:4, d:'d4x'}, {c:1, d:'d1y'}, {c:2, d:'d2y'} ]
     by g = ($.c) as j
  into { g:g, bs:i[*].b, ds:j[*].d };
;//------------------- TEST-CASE -----------------
 
join $r1, $r2 where $r1.author == $r2.bs[0] into {$r1.author, $r1.year, grp_key: $r2.g, array: $r2.bs} -> filter $.year > 1960 and $.array[1] == 'b2y' and $.grp_key == 2;

;//--------------------- RESULT ------------------

[
  {
    "array": [
      "R. L. Stine",
      "b2y"
    ],
    "author": "R. L. Stine",
    "grp_key": 2,
    "year": 1995
  },
  {
    "array": [
      "R. L. Stine",
      "b2y"
    ],
    "author": "R. L. Stine",
    "grp_key": 2,
    "year": 1977
  }
]

;//------------------- TEST-CASE -----------------
			  
      
//Returns 1 record --(Filter should be pushed below GroupBy)
[true, false, true, true, false]
	->  group by v = $ into {key: v, count: count($[*])} 
	-> filter $.key;

;//--------------------- RESULT ------------------

[
  {
    "count": 3,
    "key": true
  }
]

;//------------------- TEST-CASE -----------------

//==========================Testing Filter-FunctionCalls===================================================

registerFunction("split1", "com.acme.extensions.fn.Split1");
;//------------------- TEST-CASE -----------------

SplitCnt = fn($line) (
	count(split1($line, " "))	
);
;//------------------- TEST-CASE -----------------

$path = 'home mystuff stuff';
;//------------------- TEST-CASE -----------------


//Returns count of 14 records --(Filter should be pushed down)
$data_books -> transform each $d {n: $d.author, m: $d.year} -> filter  SplitCnt($path) < $.m -> count();

;//--------------------- RESULT ------------------

14

;//------------------- TEST-CASE -----------------


//Returns 4 records --(Filter should be pushed down)
$data_books -> transform each $d {n: $d.author, m: $d.year} -> filter SplitCnt($.n) == 2;

;//--------------------- RESULT ------------------

[
  {
    "m": 1998,
    "n": "New Rowling"
  },
  {
    "m": 1988,
    "n": "Carolyn Keene"
  },
  {
    "m": 1979,
    "n": "Old Rowling"
  },
  {
    "m": 1920,
    "n": "Carolyn Keene"
  }
]

;//------------------- TEST-CASE -----------------


//Returns 4 records --(Filter should be pushed down)
$data_books -> transform each $d {n: $d.author, m: $d.year, c: 2} -> filter SplitCnt($.n) == $.c;

;//--------------------- RESULT ------------------

[
  {
    "c": 2,
    "m": 1998,
    "n": "New Rowling"
  },
  {
    "c": 2,
    "m": 1988,
    "n": "Carolyn Keene"
  },
  {
    "c": 2,
    "m": 1979,
    "n": "Old Rowling"
  },
  {
    "c": 2,
    "m": 1920,
    "n": "Carolyn Keene"
  }
]

;//------------------- TEST-CASE -----------------


//Returns 6 records --(Filter should be pushed down)
$data_books -> transform {$.author, cnt: $.year + $.format.pages * 2} -> filter each $x $x.cnt >  SplitCnt($x.author);

;//--------------------- RESULT ------------------

[
  {
    "author": "J. K. Rowling",
    "cnt": 4611
  },
  {
    "author": "J. K. Rowling",
    "cnt": 4603
  },
  {
    "author": "J. K. Rowling",
    "cnt": 4398
  },
  {
    "author": "J. K. Rowling",
    "cnt": 3480
  },
  {
    "author": "R. L. Stine",
    "cnt": 2599
  },
  {
    "author": "Carolyn Keene",
    "cnt": 2052
  }
]

;//------------------- TEST-CASE -----------------


//Returns 1 records --(1st Predicate should be pushed down. 2nd Predicate remains the same)
$data_books -> transform each $d {n: $d.author, m: $d.year, c: SplitCnt($d.author)} -> filter $.m > 2000 and $.c == 3;

;//--------------------- RESULT ------------------

[
  {
    "c": 3,
    "m": 2007,
    "n": "J. K. Rowling"
  }
]

;//------------------- TEST-CASE -----------------



//Returns 6 record --(Predicates "$.r1.n ==  'J. K. Rowling' and $.r1.m > 200" should be pushed down below the Join,
//                      Predicate ($.Key < SplitCnt($path) * 667) should be pushed down below the GroupBy and Join,
//                      Predicate $.Min == 'J. K. Rowling' should remain as is)
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

K = join $r1, $r2 where $r1.n == $r2.author into {$r1} -> filter $.r1.n ==  'J. K. Rowling' and $.r1.m > 200;
;//------------------- TEST-CASE -----------------

K -> group by v = $.r1.year into {Key:v, Min: min($[*].r1.n)} -> filter ($.Key < SplitCnt($path) * 667) and $.Min == 'J. K. Rowling';

;//--------------------- RESULT ------------------

[
  {
    "Key": 1986,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1999,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1998,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1978,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1987,
    "Min": "J. K. Rowling"
  },
  {
    "Key": 1996,
    "Min": "J. K. Rowling"
  }
]

;//------------------- TEST-CASE -----------------



Median = fn($items) (
$sorted = $items -> sort by [$],
$sorted[long((count($sorted)/2))]);
;//------------------- TEST-CASE -----------------


//Returns 2 records --(Filter should be pushed down)
$data_books -> transform each $d {n: $d.author, m: $d.year, c: $d.price}  -> filter each $x Median($x.c) > 20;

;//--------------------- RESULT ------------------

[
  {
    "c": [
      120.5,
      110.0
    ],
    "m": 1998,
    "n": "J. K. Rowling"
  },
  {
    "c": [
      3.6,
      20.5,
      41.0
    ],
    "m": 1977,
    "n": "R. L. Stine"
  }
]

;//------------------- TEST-CASE -----------------


//=======================================================Testing Filter-Merge===================================================

//Returns count of 16 records --(Predicate should be pushed below in the THREE directions
$r1 = $data_books -> transform {author: $.author, m: $.year, $.year , c: $.format.cover};
;//------------------- TEST-CASE -----------------

$r2 = $data_books2;
;//------------------- TEST-CASE -----------------

$r3 = [{author:4}, {z:5}];
;//------------------- TEST-CASE -----------------

merge ($r1, $r2, $r3) -> filter $.author == 'J. K. Rowling' -> count();

;//--------------------- RESULT ------------------

16

;//------------------- TEST-CASE -----------------



//+++++Partial Failure (Filter followed by Filter)
//Returns 8 records --(Predicate $.d1 ==  'soft' should be pushed below the first Transform,
//                     Predicate $.d2 == $.d3 should be pushed down only before the INTO clause but not before the join,
//                     Predicate $k.d3 > 1990 should be pushed down below the Transform in $r4 AND below the transform in $r1 )     
$r1 = $data_books -> transform {n: $.author, m: $.year, $.year , c: $.format.cover} -> sort by [$.c , $.m desc];
;//------------------- TEST-CASE -----------------

$r2 = $data_books2 -> transform {x: $.author, w:$.year} -> sort by [$.w * 4];
;//------------------- TEST-CASE -----------------

$r3 = join $r1, $r2 where $r1.n == $r2.x and $r1.m == $r2.w into {d1: $r1.c, d2: $r2.w, d3: $r1.year} -> filter $.d1 ==  'soft' and $.d2 == $.d3 -> sort by [$.d2] ;
;//------------------- TEST-CASE -----------------

$r4 = $data_books -> transform each $v {d1: $v.format.cover, d3: $v.year};
;//------------------- TEST-CASE -----------------

merge ($r3, $r4) -> filter each $k $k.d3 >1990;

;//--------------------- RESULT ------------------

[
  {
    "d1": "soft",
    "d2": 1995,
    "d3": 1995
  },
  {
    "d1": "soft",
    "d2": 1998,
    "d3": 1998
  },
  {
    "d1": "hard",
    "d3": 2007
  },
  {
    "d1": "hard",
    "d3": 1999
  },
  {
    "d1": "soft",
    "d3": 1998
  },
  {
    "d1": null,
    "d3": 1998
  },
  {
    "d1": "hard",
    "d3": 1996
  },
  {
    "d1": "soft",
    "d3": 1995
  }
]

;//------------------- TEST-CASE -----------------


//====================================================Side Effect and non-deterministic=========================================
//Delete the 'true' predicate
$r1 = [1,2,3,4,5];
;//------------------- TEST-CASE -----------------

$r1 -> filter $ > 1 and true and $> randomLong();

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------



//Replace the whole query with empty input, i.e., []
$r1 = [1,2,3,4,5];
;//------------------- TEST-CASE -----------------

$r1 -> filter $ > 1 and false and $> randomLong();

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------



//Replace the whole query with empty input, i.e., []
$r1 = [1,2,3,4,5];
;//------------------- TEST-CASE -----------------

$r1 -> filter $ > 1 and null and $> randomLong();

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------



//Convert the query to a DO expression that reports empty output, i.e., []
$effect = fn($data)(
	$data -> write(file('dd')),
	[1] -> transform ($)
);
;//------------------- TEST-CASE -----------------

$r1 = [1,2,3,4,5];
;//------------------- TEST-CASE -----------------

$r1 -> $effect() -> filter $ > 1 and false and $> randomLong();

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------




//Remove the first predicate ($>1) since it is not a side effecting predicate
$effect = fn($data)(
	$data -> write(file('dd')),
	[1] -> transform ($)
);
;//------------------- TEST-CASE -----------------

$r1 = [1,2,3,4,5];
;//------------------- TEST-CASE -----------------

$r1 ->  filter $ > 1 and false and $ > $effect($r1);

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------



//=======================================================Testing Filter-Expand===================================================

//Returns 3 records --(Predicate is pushed inside the expand,
//                     UnnestFor rule will push it back outside)
$data_books -> filter exists($.price) -> transform {$.author, $.price} -> expand $.price -> filter each $d $d> 100;

;//--------------------- RESULT ------------------

[
  102222,
  120.5,
  110.0
]

;//------------------- TEST-CASE -----------------


//Returns 3 records --(Predicate is pushed inside the expand
//                     UnnestFor rule will push it back outside)
$data_books  -> expand unroll $.price -> filter $.price > 100;

;//--------------------- RESULT ------------------

[
  {
    "author": "J. K. Rowling",
    "format": {
      "cover": "hard",
      "pages": 1302
    },
    "price": 102222,
    "publisher": "Scholastic",
    "title": "Deathly Hallows",
    "year": 2007
  },
  {
    "author": "J. K. Rowling",
    "format": {
      "cover": "soft",
      "pages": 1200
    },
    "price": 120.5,
    "publisher": "XYZ",
    "title": "Deathly Hallows",
    "year": 1998
  },
  {
    "author": "J. K. Rowling",
    "format": {
      "cover": "soft",
      "pages": 1200
    },
    "price": 110.0,
    "publisher": "XYZ",
    "title": "Deathly Hallows",
    "year": 1998
  }
]

;//------------------- TEST-CASE -----------------


//Returns 2 records --(1st Predicate is pushed inside the expand,
//                     2nd Predicate is pushed before the expand )
//                     UnnestFor rule will push 1st Predicate back outside)
$data_books  -> expand unroll $.price -> filter each $d $d.price > 100 and $d.publisher == 'XYZ';

;//--------------------- RESULT ------------------

[
  {
    "author": "J. K. Rowling",
    "format": {
      "cover": "soft",
      "pages": 1200
    },
    "price": 120.5,
    "publisher": "XYZ",
    "title": "Deathly Hallows",
    "year": 1998
  },
  {
    "author": "J. K. Rowling",
    "format": {
      "cover": "soft",
      "pages": 1200
    },
    "price": 110.0,
    "publisher": "XYZ",
    "title": "Deathly Hallows",
    "year": 1998
  }
]

;//------------------- TEST-CASE -----------------


//Returns 4 records --(Predicates are pushed inside the expand)
//                     UnnestFor rule will push it back outside)
$data_books  -> expand unroll $.price -> filter $.price > 100 or $.publisher == 'XYZ';

;//--------------------- RESULT ------------------

[
  {
    "author": "J. K. Rowling",
    "format": {
      "cover": "hard",
      "pages": 1302
    },
    "price": 102222,
    "publisher": "Scholastic",
    "title": "Deathly Hallows",
    "year": 2007
  },
  {
    "author": "J. K. Rowling",
    "format": {
      "cover": "soft",
      "pages": 1200
    },
    "price": 120.5,
    "publisher": "XYZ",
    "title": "Deathly Hallows",
    "year": 1998
  },
  {
    "author": "J. K. Rowling",
    "format": {
      "cover": "soft",
      "pages": 1200
    },
    "price": 110.0,
    "publisher": "XYZ",
    "title": "Deathly Hallows",
    "year": 1998
  },
  {
    "author": "J. K. Rowling",
    "publisher": "XYZ",
    "title": "Deathly Hallows",
    "year": 1986
  }
]

;//------------------- TEST-CASE -----------------


;//------------------- TEST-DONE -----------------
