
;//------------------- TEST-CASE -----------------
//---------------------------------------------------------------------------
// Tests:
//   composite input/output adapaters
//   parallelization of union (coming soon)
//   parallelization of tee
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Composite input/output adapaters
//---------------------------------------------------------------------------

r = hdfs('R');
;//------------------- TEST-CASE -----------------

s = hdfs('S');
;//------------------- TEST-CASE -----------------

t = hdfs('T');
;//------------------- TEST-CASE -----------------


R = read(r);
;//------------------- TEST-CASE -----------------

S = read(s);
;//------------------- TEST-CASE -----------------

T = read(t);
;//------------------- TEST-CASE -----------------


// Defines a composite descriptor:
//   Read produces the union of descriptors.
//   Write partitions the values written.  It expects the values to be [i,x] pairs where
//      i is an index to a output descriptor and
//      x is value that will be written to only to descriptor[i]
//      if a key is written, it is passed to descriptor[i] as well.
compositeDescriptor = fn( descriptors )
   { inoptions:  { adapter: 'com.ibm.jaql.io.hadoop.CompositeInputAdapter' },
     outoptions: { adapter: 'com.ibm.jaql.io.hadoop.CompositeOutputAdapter' },
     descriptors
   };
;//------------------- TEST-CASE -----------------


// write even values to R and odd values to S
range(10) 
 -> transform [ mod($,2), $ ]
 -> write( compositeDescriptor( [r, s] ) )
;

;//--------------------- RESULT ------------------

{
  "descriptors": [
    {
      "location": "R",
      "type": "hdfs"
    },
    {
      "location": "S",
      "type": "hdfs"
    }
  ],
  "inoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeInputAdapter"
  },
  "outoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeOutputAdapter"
  }
}

;//------------------- TEST-CASE -----------------


// Just evens
R;

;//--------------------- RESULT ------------------

[
  0,
  2,
  4,
  6,
  8
]

;//------------------- TEST-CASE -----------------


// Just odds
S;

;//--------------------- RESULT ------------------

[
  1,
  3,
  5,
  7,
  9
]

;//------------------- TEST-CASE -----------------


// Read the union of R and S in one read.
read( compositeDescriptor([r,s]) );

;//--------------------- RESULT ------------------

[
  [
    0,
    0
  ],
  [
    0,
    2
  ],
  [
    0,
    4
  ],
  [
    0,
    6
  ],
  [
    0,
    8
  ],
  [
    1,
    1
  ],
  [
    1,
    3
  ],
  [
    1,
    5
  ],
  [
    1,
    7
  ],
  [
    1,
    9
  ]
]

;//------------------- TEST-CASE -----------------


// Try a map/reduce job
read( compositeDescriptor([r,s]) )
 -> transform $[1] + 10
 -> sort by [ $ asc ]
 -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// everything with 10 added
T;

;//--------------------- RESULT ------------------

[
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19
]

;//------------------- TEST-CASE -----------------


// Write via map/reduce
T -> transform [ ($ - 10) / 5, $ ]
  -> write( compositeDescriptor([r,s]) )
;

;//--------------------- RESULT ------------------

{
  "descriptors": [
    {
      "location": "R",
      "type": "hdfs"
    },
    {
      "location": "S",
      "type": "hdfs"
    }
  ],
  "inoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeInputAdapter"
  },
  "outoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeOutputAdapter"
  }
}

;//------------------- TEST-CASE -----------------


// 10..14 in R
R;

;//--------------------- RESULT ------------------

[
  10,
  11,
  12,
  13,
  14
]

;//------------------- TEST-CASE -----------------


// 15..19 in S
S;

;//--------------------- RESULT ------------------

[
  15,
  16,
  17,
  18,
  19
]

;//------------------- TEST-CASE -----------------


// Write via from reducer of map/reduce
T -> group by x=mod($,2) into [ x, sum($) ]
  -> write( compositeDescriptor([r,s]) )
;

;//--------------------- RESULT ------------------

{
  "descriptors": [
    {
      "location": "R",
      "type": "hdfs"
    },
    {
      "location": "S",
      "type": "hdfs"
    }
  ],
  "inoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeInputAdapter"
  },
  "outoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeOutputAdapter"
  }
}

;//------------------- TEST-CASE -----------------


// [sum([10,12,14,16,18]) = 70] in R
R;

;//--------------------- RESULT ------------------

[
  70
]

;//------------------- TEST-CASE -----------------


// [sum([11,13,15,17,19]) = 75] in S
S;

;//--------------------- RESULT ------------------

[
  75
]

;//------------------- TEST-CASE -----------------


//---------------------------------------------------------------------------
// TODO: Union
//---------------------------------------------------------------------------

range(10) 
 -> transform [ mod($,2), $ ]
 -> write( compositeDescriptor( [r, s] ) )
;

;//--------------------- RESULT ------------------

{
  "descriptors": [
    {
      "location": "R",
      "type": "hdfs"
    },
    {
      "location": "S",
      "type": "hdfs"
    }
  ],
  "inoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeInputAdapter"
  },
  "outoptions": {
    "adapter": "com.ibm.jaql.io.hadoop.CompositeOutputAdapter"
  }
}

;//------------------- TEST-CASE -----------------


read( compositeDescriptor([r,s]) );

;//--------------------- RESULT ------------------

[
  [
    0,
    0
  ],
  [
    0,
    2
  ],
  [
    0,
    4
  ],
  [
    0,
    6
  ],
  [
    0,
    8
  ],
  [
    1,
    1
  ],
  [
    1,
    3
  ],
  [
    1,
    5
  ],
  [
    1,
    7
  ],
  [
    1,
    9
  ]
]

;//------------------- TEST-CASE -----------------


union( read(r), read(s) );

;//--------------------- RESULT ------------------

[
  0,
  2,
  4,
  6,
  8,
  1,
  3,
  5,
  7,
  9
]

;//------------------- TEST-CASE -----------------


union( read(r), read(s) ) -> transform $ + 100;

;//--------------------- RESULT ------------------

[
  100,
  102,
  104,
  106,
  108,
  101,
  103,
  105,
  107,
  109
]

;//------------------- TEST-CASE -----------------


union( read(r) -> transform $ + 10,
       read(s) -> transform $ + 20) 
 -> transform $ + 100
;

;//--------------------- RESULT ------------------

[
  110,
  112,
  114,
  116,
  118,
  121,
  123,
  125,
  127,
  129
]

;//------------------- TEST-CASE -----------------


read(r) -> transform $ + 10;

;//--------------------- RESULT ------------------

[
  10,
  12,
  14,
  16,
  18
]

;//------------------- TEST-CASE -----------------


union( read(r) -> transform $ + 10,
       read(s) -> transform $ + 20 )
 -> transform $ + 100
 -> group by x = $ into { x, n: count($) }
 -> sort by [$]
;

;//--------------------- RESULT ------------------

[
  {
    "n": 1,
    "x": 110
  },
  {
    "n": 1,
    "x": 112
  },
  {
    "n": 1,
    "x": 114
  },
  {
    "n": 1,
    "x": 116
  },
  {
    "n": 1,
    "x": 118
  },
  {
    "n": 1,
    "x": 121
  },
  {
    "n": 1,
    "x": 123
  },
  {
    "n": 1,
    "x": 125
  },
  {
    "n": 1,
    "x": 127
  },
  {
    "n": 1,
    "x": 129
  }
]

;//------------------- TEST-CASE -----------------


union(
  union( read(r) -> transform $ + 10,
         read(s) -> transform $ + 20 )
   -> transform $ + 100,
  union( read(r) -> transform $ + 30,
         read(s) -> transform $ + 40 )
   -> transform $ + 200 )
 -> transform $ + 1000
;

;//--------------------- RESULT ------------------

[
  1110,
  1112,
  1114,
  1116,
  1118,
  1121,
  1123,
  1125,
  1127,
  1129,
  1230,
  1232,
  1234,
  1236,
  1238,
  1241,
  1243,
  1245,
  1247,
  1249
]

;//------------------- TEST-CASE -----------------


union(
   union( read(r) -> transform $ + 10,
          read(s) -> transform $ + 20 )
     -> transform $ + 100
     -> group by x = $ into { x, n: count($) }
     -> transform $.x + 1000,
   read(s) -> transform $ + 30
  )
 -> transform $ + 40
 -> sort by [$]
;

;//--------------------- RESULT ------------------

[
  71,
  73,
  75,
  77,
  79,
  1150,
  1152,
  1154,
  1156,
  1158,
  1161,
  1163,
  1165,
  1167,
  1169
]

;//------------------- TEST-CASE -----------------


join r in read(r), 
     s in read(s) 
    where r+1 == s
    into {r,s}
 -> sort by [$]
;

;//--------------------- RESULT ------------------

[
  {
    "r": 0,
    "s": 1
  },
  {
    "r": 2,
    "s": 3
  },
  {
    "r": 4,
    "s": 5
  },
  {
    "r": 6,
    "s": 7
  },
  {
    "r": 8,
    "s": 9
  }
]

;//------------------- TEST-CASE -----------------


join a in merge( read(r) -> transform $+10, read(s) -> transform $+20 ),
     b in merge( read(r) -> transform $+30, read(s) -> transform $+40 )
     where a + 20 == b
     into { a, b }
 -> transform { d: $ }
 -> sort by [$]
;

;//--------------------- RESULT ------------------

[
  {
    "d": {
      "a": 10,
      "b": 30
    }
  },
  {
    "d": {
      "a": 12,
      "b": 32
    }
  },
  {
    "d": {
      "a": 14,
      "b": 34
    }
  },
  {
    "d": {
      "a": 16,
      "b": 36
    }
  },
  {
    "d": {
      "a": 18,
      "b": 38
    }
  },
  {
    "d": {
      "a": 21,
      "b": 41
    }
  },
  {
    "d": {
      "a": 23,
      "b": 43
    }
  },
  {
    "d": {
      "a": 25,
      "b": 45
    }
  },
  {
    "d": {
      "a": 27,
      "b": 47
    }
  },
  {
    "d": {
      "a": 29,
      "b": 49
    }
  }
]

;//------------------- TEST-CASE -----------------



join a in merge( join r in read(r), s in read(s) where r+1 == s into {r,s},
                 join r in read(r), s in read(s) where r+3 == s into {r,s} ),
     b in merge( join r in read(r), s in read(s) where r+5 == s into {r,s},
                 join r in read(r), s in read(s) where r+7 == s into {r,s} )
     where a.r == b.r
     into { a, b }
 -> transform { d: $ }
 -> sort by [$]
;

;//--------------------- RESULT ------------------

[
  {
    "d": {
      "a": {
        "r": 0,
        "s": 1
      },
      "b": {
        "r": 0,
        "s": 5
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 0,
        "s": 1
      },
      "b": {
        "r": 0,
        "s": 7
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 0,
        "s": 3
      },
      "b": {
        "r": 0,
        "s": 5
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 0,
        "s": 3
      },
      "b": {
        "r": 0,
        "s": 7
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 2,
        "s": 3
      },
      "b": {
        "r": 2,
        "s": 7
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 2,
        "s": 3
      },
      "b": {
        "r": 2,
        "s": 9
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 2,
        "s": 5
      },
      "b": {
        "r": 2,
        "s": 7
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 2,
        "s": 5
      },
      "b": {
        "r": 2,
        "s": 9
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 4,
        "s": 5
      },
      "b": {
        "r": 4,
        "s": 9
      }
    }
  },
  {
    "d": {
      "a": {
        "r": 4,
        "s": 7
      },
      "b": {
        "r": 4,
        "s": 9
      }
    }
  }
]

;//------------------- TEST-CASE -----------------



//---------------------------------------------------------------------------
// Tee 
//---------------------------------------------------------------------------

range(10) -> write(r);

;//--------------------- RESULT ------------------

{
  "location": "R",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

range(0) -> write(s);

;//--------------------- RESULT ------------------

{
  "location": "S",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

range(0) -> write(t);

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


R;

;//--------------------- RESULT ------------------

[
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9
]

;//------------------- TEST-CASE -----------------

S;

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------

T;

;//--------------------- RESULT ------------------

[]

;//------------------- TEST-CASE -----------------



// Very simple tee that writes two copies of a file
R -> tee( -> write(s) )
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

S;

;//--------------------- RESULT ------------------

[
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9
]

;//------------------- TEST-CASE -----------------

T;

;//--------------------- RESULT ------------------

[
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9
]

;//------------------- TEST-CASE -----------------


// Very simple tee for more than one expression
R -> tee( -> transform $ + 1 -> write(s),
          -> transform $ + 2 -> write(t) )
  -> transform $ + 3
  -> write(hdfs('U'))
;

;//--------------------- RESULT ------------------

{
  "location": "U",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

S;

;//--------------------- RESULT ------------------

[
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10
]

;//------------------- TEST-CASE -----------------

T;

;//--------------------- RESULT ------------------

[
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11
]

;//------------------- TEST-CASE -----------------

read(hdfs('U'));

;//--------------------- RESULT ------------------

[
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12
]

;//------------------- TEST-CASE -----------------


// Forms a single map job writing to two files
//   note: tee(a, -> e) == tee(a, f(i) i -> e)
R -> transform $ + 200
  -> tee( 
       -> transform $ + 10 
       -> write(s) 
     )
  -> transform $ + 20
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 210..219
S;

;//--------------------- RESULT ------------------

[
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219
]

;//------------------- TEST-CASE -----------------


// 220..229
T;

;//--------------------- RESULT ------------------

[
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229
]

;//------------------- TEST-CASE -----------------



// Without a leading transform
R -> tee( 
      -> transform $+10 
      -> write(s) 
     )
  -> transform $+20
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 10..19
S;

;//--------------------- RESULT ------------------

[
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19
]

;//------------------- TEST-CASE -----------------


// 20..29
T;

;//--------------------- RESULT ------------------

[
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29
]

;//------------------- TEST-CASE -----------------



// With a stream returned instead of writing
R -> transform $+100
  -> tee( -> transform $+10 -> write(s) )
  -> transform $+20
;

;//--------------------- RESULT ------------------

[
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129
]

;//------------------- TEST-CASE -----------------


// 110..119
S;

;//--------------------- RESULT ------------------

[
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119
]

;//------------------- TEST-CASE -----------------



// This should eliminates the tee as dead code, but it doesn't yet...
R -> transform $+200
  -> tee( -> transform $+10 )
  -> transform $+20
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 220..229
T;

;//--------------------- RESULT ------------------

[
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229
]

;//------------------- TEST-CASE -----------------


// Make sure filter and expand work too.
R -> transform $+100
  -> tee( -> filter $ < 107 -> expand [$+200, $+300] -> write(s) )
  -> filter $ > 103 
  -> transform $+400 
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 300..306 + 400..406
S;

;//--------------------- RESULT ------------------

[
  300,
  400,
  301,
  401,
  302,
  402,
  303,
  403,
  304,
  404,
  305,
  405,
  306,
  406
]

;//------------------- TEST-CASE -----------------


// 504..509
T;

;//--------------------- RESULT ------------------

[
  504,
  505,
  506,
  507,
  508,
  509
]

;//------------------- TEST-CASE -----------------



c = hdfs('C');
;//------------------- TEST-CASE -----------------

d = hdfs('D');
;//------------------- TEST-CASE -----------------

f = hdfs('F');
;//------------------- TEST-CASE -----------------

g = hdfs('G');
;//------------------- TEST-CASE -----------------


// This should produce one map-only job
R -> transform { a: $ }
  -> tee( -> transform { b: $.a }
          -> tee( -> transform { c: $.b } 
                  -> write(c) )
          -> transform { d: $.b } 
          -> write(d) )
  -> transform { e: $.a }
  -> tee( -> transform { f: $.e } 
          -> write(f) )
  -> transform { g: $.e } 
  -> write(g)
;

;//--------------------- RESULT ------------------

{
  "location": "G",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// c recs
read(c);

;//--------------------- RESULT ------------------

[
  {
    "c": 0
  },
  {
    "c": 1
  },
  {
    "c": 2
  },
  {
    "c": 3
  },
  {
    "c": 4
  },
  {
    "c": 5
  },
  {
    "c": 6
  },
  {
    "c": 7
  },
  {
    "c": 8
  },
  {
    "c": 9
  }
]

;//------------------- TEST-CASE -----------------


// d recs
read(d);

;//--------------------- RESULT ------------------

[
  {
    "d": 0
  },
  {
    "d": 1
  },
  {
    "d": 2
  },
  {
    "d": 3
  },
  {
    "d": 4
  },
  {
    "d": 5
  },
  {
    "d": 6
  },
  {
    "d": 7
  },
  {
    "d": 8
  },
  {
    "d": 9
  }
]

;//------------------- TEST-CASE -----------------


// f recs
read(f);

;//--------------------- RESULT ------------------

[
  {
    "f": 0
  },
  {
    "f": 1
  },
  {
    "f": 2
  },
  {
    "f": 3
  },
  {
    "f": 4
  },
  {
    "f": 5
  },
  {
    "f": 6
  },
  {
    "f": 7
  },
  {
    "f": 8
  },
  {
    "f": 9
  }
]

;//------------------- TEST-CASE -----------------


// g recs
read(g);

;//--------------------- RESULT ------------------

[
  {
    "g": 0
  },
  {
    "g": 1
  },
  {
    "g": 2
  },
  {
    "g": 3
  },
  {
    "g": 4
  },
  {
    "g": 5
  },
  {
    "g": 6
  },
  {
    "g": 7
  },
  {
    "g": 8
  },
  {
    "g": 9
  }
]

;//------------------- TEST-CASE -----------------



// Share a reducer after aggregation
R -> transform { x: mod($,3), y: $ }                 // 0,0; 1,1; 2,2; 0,3; 1,4; 2,5; 0,6; 1,7; 2,8; 0,9;
  -> group by x = $.x into { x, s: sum($[*].y) }     // 0,18; 1,12; 2,15;
  -> tee( -> filter $.x <= 1                         // 0,18; 1,12;
          -> write(s) )
  -> filter $.x >= 1                                 // 1,12; 2,15;
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 0,18; 1,12;
S -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "s": 18,
    "x": 0
  },
  {
    "s": 12,
    "x": 1
  }
]

;//------------------- TEST-CASE -----------------


// 1,12; 2,15;
T -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "s": 12,
    "x": 1
  },
  {
    "s": 15,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------


// Share a reducer with aggregation in the tee
// TODO: This could use combiners but it doesn't yet...
R -> transform { x: mod($,3), y: $ }                 // 0,0; 1,1; 2,2; 0,3; 1,4; 2,5; 0,6; 1,7; 2,8; 0,9;
  -> group by x = $.x into { x, ys: $[*].y }         // 0,[0,3,6,9]; 1,[1,4,7]; 2,[2,5,8];
  -> tee( -> transform { $.x, s: sum($.ys) }         // 0,18; 1,12; 2,15;
          -> write(s) )
  -> transform { $.x, t: count($.ys) }               // 0,4; 1,3; 2,3;
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


// 0,18; 1,12; 2,15;
S -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "s": 18,
    "x": 0
  },
  {
    "s": 12,
    "x": 1
  },
  {
    "s": 15,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------


// 0,4; 1,3; 2,3;
T -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "t": 4,
    "x": 0
  },
  {
    "t": 3,
    "x": 1
  },
  {
    "t": 3,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------


// Tee where one is not shareable
R -> transform { x: mod($,3), y: $ }
  -> tee( -> group by x=$.x 
                into { x, n: min($[*].y) }
          -> write(s) )
  -> filter $.x < 2
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------


S -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "n": 0,
    "x": 0
  },
  {
    "n": 1,
    "x": 1
  },
  {
    "n": 2,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------

T;

;//--------------------- RESULT ------------------

[
  {
    "x": 0,
    "y": 0
  },
  {
    "x": 1,
    "y": 1
  },
  {
    "x": 0,
    "y": 3
  },
  {
    "x": 1,
    "y": 4
  },
  {
    "x": 0,
    "y": 6
  },
  {
    "x": 1,
    "y": 7
  },
  {
    "x": 0,
    "y": 9
  }
]

;//------------------- TEST-CASE -----------------


// Tee where the other is not sharable
R -> transform { x: mod($,3), y: $ }
  -> tee( -> filter $.x > 1
          -> write(s) )
  -> group by a=$.x 
      into { a, m: max($[*].y) }
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

S;

;//--------------------- RESULT ------------------

[
  {
    "x": 2,
    "y": 2
  },
  {
    "x": 2,
    "y": 5
  },
  {
    "x": 2,
    "y": 8
  }
]

;//------------------- TEST-CASE -----------------

T -> sort by [$.a];

;//--------------------- RESULT ------------------

[
  {
    "a": 0,
    "m": 9
  },
  {
    "a": 1,
    "m": 7
  },
  {
    "a": 2,
    "m": 8
  }
]

;//------------------- TEST-CASE -----------------


// Tee that is not sharable at all
// TODO: this example currently does a dumb thing: 
// It writes two temps with the exactly the same stuff.
R -> transform { x: mod($,3), y: $ }
  -> tee( -> group by x=$.x 
                into { x, n: min($[*].y) }
          -> write(s) )
  -> group by a=$.x 
      into { a, m: max($[*].y) }
  -> write(t)
;

;//--------------------- RESULT ------------------

{
  "location": "T",
  "type": "hdfs"
}

;//------------------- TEST-CASE -----------------

S -> sort by [$.x];

;//--------------------- RESULT ------------------

[
  {
    "n": 0,
    "x": 0
  },
  {
    "n": 1,
    "x": 1
  },
  {
    "n": 2,
    "x": 2
  }
]

;//------------------- TEST-CASE -----------------

T -> sort by [$.a];

;//--------------------- RESULT ------------------

[
  {
    "a": 0,
    "m": 9
  },
  {
    "a": 1,
    "m": 7
  },
  {
    "a": 2,
    "m": 8
  }
]

;//------------------- TEST-CASE -----------------


;//------------------- TEST-DONE -----------------
