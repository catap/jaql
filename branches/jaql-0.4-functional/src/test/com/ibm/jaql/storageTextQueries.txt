hdfsShell("-copyFromLocal build/test/cache/data/delimited.del delimited.del") * 0;
hdfsShell("-copyFromLocal build/test/cache/data/delimited-invalid1.del delimited-invalid1.del") * 0;
hdfsShell("-copyFromLocal build/test/cache/data/delimited-invalid2.del delimited-invalid2.del") * 0;
hdfsShell("-copyFromLocal build/test/cache/data/delimited-invalid3.del delimited-invalid3.del") * 0;
hdfsShell("-copyFromLocal build/test/cache/data/lines.txt lines.txt") * 0;
hdfsShell("-copyFromLocal build/test/cache/data/lines-boolean.txt lines-boolean.txt") * 0;
hdfsShell("-copyFromLocal build/test/cache/data/lines-invalid.txt lines-invalid.txt") * 0;
hdfsShell("-copyFromLocal build/test/cache/data/lines-numeric.txt lines-numeric.txt") * 0;
hdfsShell("-copyFromLocal build/test/cache/data/lines-with-null.txt lines-with-null.txt") * 0;

// test readers
$f = "delimited.del";
read(lines($f));
read(del($f));
read(del($f, { quoted: false }));
read(del($f, { quoted: null })); // should fail
read(del($f, { delimiter: null })); // should fail

// test field information
read(del($f, { fields: ["c1", "c2", "c3"] }));
read(del($f, { fields: ["c3", "c1", "c2"] }));
read(del($f, { fields: null }));

read(del($f, { fields: { c1: schema string, c2:schema string, c3:schema string } })); // should fail
read(del($f, { fields: ["c1", "c2", 3 ] })); // should fail
read(del($f, { fields: ["c1", "c2", "c3", "c4"] })); // should fail

// test invalid files
$f = "delimited-invalid1.del";
read(del($f));                      // should fail
read(del($f, { quoted: false }));   // should work

$f = "delimited-invalid2.del";
read(del($f));                      // should fail
read(del($f, { quoted: false }));   // should work

$f = "delimited-invalid3.del";
read(del($f));                      // should fail
read(del($f, { quoted: false }));   // should fail

// test conversion of atomic types
convert("1", schema long);
convert("1.123", schema double);
convert("1.123", schema decfloat);
convert("abcd", schema string);
convert("true", schema boolean);
convert("1", schema long?);
convert("1.123", schema double?);
convert("1.123", schema decfloat?);
convert("abcd", schema string?);
convert("true", schema boolean?);
convert(null, schema long?);
convert(null, schema double?);
convert(null, schema decfloat?);
convert(null, schema string?);
convert(null, schema boolean?);
convert(null, schema long); // should fail
convert("1", schema long(min=0)); // should fail (for the moment)

// test conversion of arrays
convert(["a","1"], schema [ string, long ]);
convert(["a","1"], schema [ string, long ]?);
convert(null, schema [ string, long ]?);
convert(["a","1"], schema [ string, long? ]);
convert(["a",null], schema [ string, long? ]);

convert(["a","1","1"], schema [ string, long ]); // should fail
convert(["a"], schema [ string, long ]); // should fail
convert(["a",1], schema [ string, long ]); // should fail
convert(null, schema [ string, long ]); // should fail


// test conversion of records
convert({a:"a", b:"2"}, schema { a:string, b: long });
convert({a:"a", b:"2"}, schema { a:string, b: long }?);
convert(null, schema { a:string, b: long }?);
convert({a:"a", b:"2"}, schema { a:string, b: long? });
convert({a:"a", b:null}, schema { a:string, b: long? });

convert({a:"a", b:"2", c:"1"}, schema { a:string, b: long }); // should fail
convert({a:"a"}, schema { a:string, b: long }); // should fail
convert({a:"a", b:1}, schema { a:string, b: long }); // should fail
convert(null, schema { a:string, b: long }); // should fail

// all together
schemaof(read(del("delimited.del", { fields: ["c1", "c2", "c3"], convert: schema { c1:string?, c2:string?, c3:long? } })));
schemaof(read(del("delimited.del", { convert: schema [ string?, string?, long? ] })));

read(del("delimited.del", { convert: schema [ string?, string?, long? ] }));
schemaof(read(del("delimited.del", { convert: schema [ string?, string?, long? ] })));
read(del("delimited.del", { fields: ["c1", "c2", "c3"], convert: schema { c1:string?, c2:string?, c3:long? } }));

// Tests for the lines() interface method
$l = "lines.txt";
$lb = "lines-boolean.txt";
$li = "lines-invalid.txt";
$ln = "lines-numeric.txt";
$lwn = "lines-with-null.txt";

// Test read(lines()) which should return an array of strings. This should succeed for all the files.
read(lines($l));
read(lines($lb));
read(lines($li));
read(lines($ln));
read(lines($lwn));

// Test read(lines()) with the convert option.
read(lines($l,{convert: schema string})); // Test for the default schema.
read(lines($l,{convert: schema long})); // This should fail since the file is mixture of multiple types.
read(lines($li,{convert: schema long})); // This should fail since the file has non-numeric characters.
read(lines($ln,{convert: schema long}));
read(lines($ln,{convert: schema double}));
read(lines($lb,{convert: schema boolean}));
read(lines($lb,{convert: schema long})); // This should fail since the input file contains booleans.
read(lines($lwn,{convert: schema string})); // This should fail since the input file has nulls.
read(lines($lwn,{convert: schema long?}));

// Test for invalid arguments to the convert option.
read(lines($l,{convert: schema [long]}));
read(lines($l,{convert: schema {f1: long}}));

$out = "tmpout/out-file.txt";

// Test for write(lines()) and checking whether the written files have data in the specified format
[1,2,3,4,5,6,7,8,9,10,100,1000,10000,100000] -> write(lines($out));
read(lines($out,{convert: schema long}));
read(lines($out,{convert: schema double}));

[true,false,false,false,true,true,false] -> write(lines($out));
read(lines($out,{convert: schema boolean}));

[1,2,3.4,4,true,6,'Hello',8,'World',0.78] -> write(lines($out));
read(lines($out));

[1,2,3,4,null,6] -> write(lines($out));
read(lines($out));
read(lines($out,{convert: schema long?}));
read(lines($out,{convert: schema long})); // This should fail since the file contains null.

[true, false, null] -> write(lines($out));
read(lines($out, {convert: schema boolean?}));

// -- Remove all the temporary files created.
hdfsShell("-rm delimited.del") * 0;
hdfsShell("-rm delimited-invalid1.del") * 0;
hdfsShell("-rm delimited-invalid2.del") * 0;
hdfsShell("-rm delimited-invalid3.del") * 0;
hdfsShell("-rm lines.txt") * 0;
hdfsShell("-rm lines-boolean.txt") * 0;
hdfsShell("-rm lines-invalid.txt") * 0;
hdfsShell("-rm lines-numeric.txt") * 0;
hdfsShell("-rm lines-with-null.txt") * 0;
hdfsShell("-rmr tmpout") * 0;