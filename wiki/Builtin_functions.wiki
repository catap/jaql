#summary JAQL built-in function list - autogenerated
#labels generated
#sidebar TableOfContents
<wiki:toc max_depth="2" />
=system=
== batch() ==

  _*Description*_ batch( [T] A , long n ) returns [[T]] 
 
 Takes an array A and groups it arbitrarily into blocks of size <= n.
 Typically the last every block but the last block has size n, but
 batch can be run in parallel and could produce more small blocks.
 
 Example:
 
 range(1,10) -> batch(3);
 ==> [ [1,2,3], [4,5,6], [7,8,9], [10] ]

  _*Parameters*_ (2)

== exec() ==

  _*Description*_ 

  _*Parameters*_ (2)

== externalfn() ==

  _*Description*_ An expression that constructs a JSON value for a Java UDF

  _*Parameters*_ (1)

== ls() ==

  _*Description*_ ls(glob)

  _*Parameters*_ (1)

== R() ==

  _*Description*_ A function allowing invocation of R from within Jaql.
 
 R(fn, args=[item arg1, ..., item argN], 
 inSchema=[schema arg1, ...,schema argN], outSchema=null, 
 init, initInline=true, binary=false, flexible=false)
 
 A single R process is forked per RFn instance (i.e., call site in the query).
 The R process is forked and the init script/string is passed to R only on the 
 first invocation.
 
 To configure R, add -DR.home=<path to R> and -DR.args=<args to R> to the 
 VM arguments. 
 
 // TODO: need jaql.conf

  _*Parameters*_ (1 - 8)

----
=pragma=
== const() ==

  _*Description*_ This is a pragma function to force const evaluation.

  _*Parameters*_ (1)

== inline() ==

  _*Description*_ This is a pragma function to force let/global inlining.

  _*Parameters*_ (1)

== unrollLoop() ==

  _*Description*_ A pragma to encourage loop unrolling.

  _*Parameters*_ (1)

----
=core=
== catch() ==

  _*Description*_ Wrap this expression around any child expression that needs to be guarded
 for exceptions. Usage is as follows:
 
 catch(child expr, { errThresh: long } opts);
 
 Note the following consequences of this expression:
 1. It is blocking: all values produced by child must be valid, 
                    which precludes streaming computation to the caller of "catch"
 2. If an error occurs in the child, the exception handling options determine what happens next.
    The errThresh lets the user specify how many errors can happen at the call-site of the specific
    catch expression. If the number of exceptions exceeds errThresh, then the exception is
    propagated up. Otherwise, the exception is simply logged. By default, if opts is not specified,
    errThresh is set to 0, e.g., exceptions propagate up.

  _*Parameters*_ (1 - 3)

== compare() ==

  _*Description*_ 

  _*Parameters*_ (2)

== daisyChain() ==

  _*Description*_ Calls the composition of a set of single argument functions.
 
 daisyChain(T0 input, [f1, f2, ..., fn]) returns Tn
 
 where:
   f1(T0) returns T1,
   f2(T1) returns T2,
   fn(Tn) returns Tn
   
 A compose function that returns a function is easily created from this one:
   compose = fn(fns) fn(input) daisyChain(input, fns)

  _*Parameters*_ (2)

== diamondTag() ==

  _*Description*_ This function is used internally during the rewriting of tee().  
 It is not intended for general use.
 
 e -> tagDiamond( f0, ..., fn )
 
 Exactly the same as:
   e -> expand union( [$] -> f0() -> transform [0,$], ..., 
                      [$] -> fn() -> transform [n,$] )

  _*Parameters*_ (2 - 3)

== expectException() ==

  _*Description*_ This function is used by tests to mask expected exceptions.

  _*Parameters*_ (1 - 2)

== getHdfsPath() ==

  _*Description*_ return the absolute path in HDFS

  _*Parameters*_ (1)

== getOptions() ==

  _*Description*_ Return the system options record.

  _*Parameters*_ (0)

== groupCombine() ==

  _*Description*_ groupCombine(input $X, initialFn, partialFn, finalFn) => $Y
    initialFn = fn($k,$X) e1 => $P
    partialFn = fn($k,$P) => $P
    finalFn = fn($k,$P) => $Y

  _*Parameters*_ (4)

== index() ==

  _*Description*_ element(array, index) is the same as array[index], but it captures a simpler 
 case that doesn't use path expressions. array[index] is transformed to use the
 element function for better performance.

  _*Parameters*_ (2)

== jump() ==

  _*Description*_ jump(i, e0, ..., en) return one of e0 to en based on i.
 i must be exactly one of 0...n
 Like 'if', it should only evaluate one of e0 to en.
 
 Exactly the same as:
   if( i == 0 ) e0
   else if( i == 1 ) e1
   ...
   else if( i == n ) en
   else raise error

  _*Parameters*_ (2 - 3)

== listVariables() ==

  _*Description*_ List the active global variables.
   [{ var: string, schema: schema, isTable: boolean }...]

  _*Parameters*_ (0)

== mergeContainers() ==

  _*Description*_ DEPRECATED: is this used anywhere?
 Merge a set of arrays into one array in order, or a set of records into one record.  Nulls are ignored.

  _*Parameters*_ (1 - 2)

== perf() ==

  _*Description*_ 

  _*Parameters*_ (1)

== perPartition() ==

  _*Description*_ 

  _*Parameters*_ (2)

== range() ==

  _*Description*_ range(size)      = [0,size-1]
 range(size,null) = [0,size-1]
 range(start,end) = [start,end]
 range(start,end,skip) = if skip > 0 then for(i = start, i <= end, i += skip)
                         else error
 range(size,null,skip) = if skip > 0 then for(i = 0, i < size, i += skip)
                         else error

  _*Parameters*_ (1 - 3)

== registerExceptionHandler() ==

  _*Description*_ 

  _*Parameters*_ (1)

== retag() ==

  _*Description*_ This function is used internally during the rewriting of tee().  
 It is not intended for general use.
 
 e -> retag( f1, ..., fn )
 
 Exactly the same as:
   e -> expand ( jump($[0], f1, ..., fn)( [$[1]] ) -> transform[i,$[0]] )

  _*Parameters*_ (2 - 3)

== setOptions() ==

  _*Description*_ Set system options.

  _*Parameters*_ (1)

== skipUntil() ==

  _*Description*_ Skip the first elements of input (in order) until the predicate is true,
 return all elements after the test fires.
 If inclusive is true (the default) then return the element that triggered
 the condition.  Otherwise, exclude it. 
 
 input: [T...]? -> skipUntil( when: fn(T): bool, inclusive:bool = true ): [T...]

  _*Parameters*_ (2 - 3)

== streamSwitch() ==

  _*Description*_ e0 -> streamSwitch( f0, ..., fn )
 ===
 ( x = e0,
   union( x -> filter $[0] == 0 -> transform $[1] -> f0(),
          ...
          x -> filter $[0] == n -> transform $[1] -> fn() ) 
 )
 
 Except that the functions can be called any number of times and in any order.
 Something like this:
 
 ( x = e0,
   union( x -> filter $[0] == 0 -> transform $[1] -> batch(n=?) -> expand f0($),
          ...
          x -> filter $[0] == n -> transform $[1] -> batch(n=?) -> expand fn($) ) 
 )
 
 The actual implementation is to stream into function fi any consecutive rows
 with index i.  Something like this:
 
 ( x = e0,
   x -> tumblingWindow( stop = fn(first,next) first[0] != next[0] )
     -> expand each p fi( p -> transform $[1] ) // where i is p[j][0] for all j in the window
 )

  _*Parameters*_ (2 - 3)

== tag() ==

  _*Description*_ This function is used internally during the rewriting of tee().  
 It is not intended for general use.
 
 e -> tag(i)
 
 Exactly the same as:
   e -> transform [i,$]

  _*Parameters*_ (2)

== tagFlatten() ==

  _*Description*_ This function is used internally during the rewriting of tee().  
 It is not intended for general use.
 
 e -> tagFlatten( int index, int numToExpand )
 
 Exactly the same as:
   e -> transform each x (
         i = x[0],
         v = x[1],
         if( i < index ) then x
         else if( i > index ) then [i + numToExpand-1, v]
         else ( assert(0 <= v[0] < numToExpand), [ v[0] + index, v[1] ] ))
 
 Example:
   [ [0,a], [1,[0,b]], [1,[1,c]], [2,d] ] -> tagFlatten( 1, 2 )
  ==
   [ [0,a], [1,b], [2,c], [3,d] ]

  _*Parameters*_ (3)

== tagSplit() ==

  _*Description*_ This function is used internally during the rewriting of tee().  
 It is not intended for general use.
 
 e -> tagSplit( f0, ..., fn )
 
 Exactly the same as:
   ( X = e, 
     X -> filter $[0] == 0 -> f0() -> transform $[1], ...
     X -> filter $[0] == n -> fn() -> transform $[1] )
     
 Also the same as:
   ( e -> write( composite( [t0, ..., tn] ) ),
     read(t0) -> f0(), ...
     read(tn) -> fn() )

  _*Parameters*_ (2 - 3)

== tee() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

== timeout() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

== until() ==

  _*Description*_ Return the first elements of input (in order) until the predicate is true.
 If inclusive is true (the default) then include the element that triggered
 the condition.  Otherwise, exclude it. 
 
 input: [T...]? -> until( when: fn(T): bool, inclusive:bool = true ): [T...]

  _*Parameters*_ (2 - 3)

----
=hadoop=
== buildModel() ==

  _*Description*_ Build a data mining model in parallel.
 
 buildModel( 
 { input: fd,
   output: fd,  // TODO: this could be eliminated, but required now and gets model
   init: fn() -> model,
   partial: fn($part,$model) -> pmodel, // $part is array of input items
   combine: fn($pmodels,$model) -> model, // $pmodels is array of partial models
   done: fn($oldModel, $newModel) -> bool
  })
 -> model

  _*Parameters*_ (1)

== chainedMap() ==

  _*Description*_ Run a function *sequentially* but piecemeal over an input array.
 
 chainedMap( 
 { input: fd,
   output: fd,  // TODO: this could be eliminated, but required now and gets state
   init: state,
   map: fn(part,state) -> state, // part is array of input items
   schema?: state schema
  })
 -> state

  _*Parameters*_ (1)

== loadJobConf() ==

  _*Description*_ Usage: { name: string } loadJobConf( string? filename )
 if filename to conf is not specified, then the default JobConf is loaded

  _*Parameters*_ (0 - 1)

== mapReduce() ==

  _*Description*_ 

  _*Parameters*_ (1)

== mrAggregate() ==

  _*Description*_ 

  _*Parameters*_ (1)

== nativeMR() ==

  _*Description*_ Usage: { status: boolean } nativeMR( { job conf settings } conf , { apiVersion: "0.0" | "1.0" } options );
 
 Launch a stand-alone map-reduce job that is exclusively described by job conf settings.
 
 Example: { status: true } nativeMR( loadJobConf( "myJob.conf" ) );

  _*Parameters*_ (1 - 2)

== readConf() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

----
=io=
== arrayRead() ==

  _*Description*_ 

  _*Parameters*_ (1)

== del() ==

  _*Description*_ An expression that constructs an I/O descriptor for HDFS file access.

  _*Parameters*_ (1 - 2)

== expandFD() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

== file() ==

  _*Description*_ An expression that constructs an I/O descriptor for local file access.

  _*Parameters*_ (1 - 2)

== fileSplitToRecord() ==

  _*Description*_ Return the fields of a raw FileSplit.
 
 fileSplitToRecord( split: { class: string, split: binary, * } ):
   { path: string, start: long, length: long, locations: [string...] }

  _*Parameters*_ (1)

== HadoopTemp() ==

  _*Description*_ Creates a file descriptor for temporary files used by Jaql. Takes a schema argument that
 describes the schema of the individual values written to the file.

  _*Parameters*_ (0 - 1)

== hbaseRead() ==

  _*Description*_ hbaseRead( tableExpr, {columns: columnExpr, lowKey:lowKeyExpr,
 highKey:highKeyExpr, timestamp:timestampExpr}? )
  - string tableName <- evaluate tableExpr - JArray columns <- evaluate
 columnExpr - string lowKey <- evaluate lowKeyExpr - string highKey <-
 evaluate highKeyExpr - LongItem timestamp <- evaluate timestamp
 
 Open a scanner on tableName, default column family and return an Iter that
 wraps each hbase row in a JMap. Each tuple is generated by constructing one
 or more ExprPairs. Each ExprPair p is generated by using the column name for
 p.name and the value for p.value

  _*Parameters*_ (1 - 2)

== hbaseWrite() ==

  _*Description*_ 

  _*Parameters*_ (2 - 3)

== hdfs() ==

  _*Description*_ An expression that constructs an I/O descriptor for HDFS file access.

  _*Parameters*_ (1 - 2)

== hdfsShell() ==

  _*Description*_ An expression for running HDFS shell. It is equivalent to <i>hadoop fs</i>.

  _*Parameters*_ (1)

== http() ==

  _*Description*_ An expression that constructs an I/O descriptor for local file access.

  _*Parameters*_ (1 - 3)

== httpGet() ==

  _*Description*_ 

  _*Parameters*_ (1 - 3)

== inputSplits() ==

  _*Description*_ Take a i/o descriptor and return a list of raw splits:
    [{ class: string, split: binary, locations: [string...] }...]

  _*Parameters*_ (1)

== jaqltemp() ==

  _*Description*_ An expression that constructs an I/O descriptor for jaqls temp file access.

  _*Parameters*_ (2)

== lines() ==

  _*Description*_ An expression that constructs an I/O descriptor for HDFS file access.

  _*Parameters*_ (1 - 2)

== localRead() ==

  _*Description*_ An expression used for reading data into jaql. The only different between
 localRead and Read is that localRead is disabled for mapReduce rewirte.

  _*Parameters*_ (1)

== localWrite() ==

  _*Description*_ 

  _*Parameters*_ (2)

== makeFileSplit() ==

  _*Description*_ Constructs a raw FileSplit.  You should know what you're doing if you're using this!
 
 makeFileSplit( file: string, start: long, length: long, hosts: [string...] ):
   { class: string, split: binary, locations:[string...] }

  _*Parameters*_ (4)

== read() ==

  _*Description*_ An expression used for reading data into jaql. It is called as follows:
 
 <pre>
 read({type: '...', 
       location: '...', 
       inoptions: {...}})
 </pre>
 
 The type specifies which InputAdapter to use, the location specifies the
 address from which the adapter will read. The optional inoptions further
 parameterize the adapter's behavior. <br>
 If inoptions are not specified, then default options that are registered for
 the type at the AdapterStore will be used. If no options are specified and
 there are no defaults registered, it is an error. If both options are
 specified and default options are registered, then the union of option fields
 will be used. If there are duplicate names, then the query options will be
 used as an override.

  _*Parameters*_ (1)

== readAdapterRegistry() ==

  _*Description*_ Load the registry from the given file
 
 readAdapterRegistry(string filename) returns file name

  _*Parameters*_ (1)

== readSplit() ==

  _*Description*_ An expression used for reading data from a single split into jaql.

  _*Parameters*_ (2)

== registerAdapter() ==

  _*Description*_ Register a key, value pair.
 
 registerAdapter({type: string, inOptions: {}, outOptions: {}})

  _*Parameters*_ (1)

== unregisterAdapter() ==

  _*Description*_ Unregister a key, value pair.
 
 unregisterAdapter(string key) returns key

  _*Parameters*_ (1)

== write() ==

  _*Description*_ An expression used for writing external data. It is called as follows:
 
 <pre>
 write({type: '...', 
        location: '...', 
        outoptions: '...', 
        inoptions: '...'}
       , expr);
 </pre>
 
 The <tt>type</tt> specifies which {@link OutputAdapter} to use, the
 <tt>location</tt> specifies the address to which the adapter will write. The
 optional <tt>outoptions</tt> further parameterize the adapter's behavior. The
 optional <tt>inoptions</tt> can be used to parametrize a read expression that
 takes as input a write expression (e.g., <tt>read(write({...}, expr)) </tt>).
 <p>
 If <tt>outoptions</tt> or <tt>inoptions</tt> are unspecified, then default
 options that are registered for the type at the {@link AdapterStore} will be
 used. If no options are specified and there are no defaults registered, it is
 an error. If both options are specified and default options are registered,
 then the union of option fields will be used. If there are duplicate names,
 then the query options will be used as an override.

  _*Parameters*_ (2)

== writeAdapterRegistry() ==

  _*Description*_ Write the registry to a given file
 
 writeAdapterRegistry(string filename) returns null

  _*Parameters*_ (1)

----
=array=
== append() ==

  _*Description*_ append($a, $b, ...) ==> unnest [ $a, $b, ... ] NOT when $a or $b are
 non-array (and non-null), but that's probably an improvement. NOT when $a or
 $b are null, but the change to unnest to remove nulls will fix that should
 append(null, null) be null? it would break any unnest definition... Push
 unnest into ListExpr?

  _*Parameters*_ (1 - 2)

== arrayToRecord() ==

  _*Description*_ 

  _*Parameters*_ (2)

== asArray() ==

  _*Description*_ This function ensures that input returns an array.

  _*Parameters*_ (1)

== columnwise() ==

  _*Description*_ 

  _*Parameters*_ (1)

== deempty() ==

  _*Description*_ 

  _*Parameters*_ (1)

== distinct() ==

  _*Description*_ 

  _*Parameters*_ (1)

== enumerate() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

== exists() ==

  _*Description*_ exists(null) = null exists([]) = false exists([...]) = true, when the array
 has at least one element (even a null) exists(...) = true, when the argument
 is not an array or a null

  _*Parameters*_ (1)

== lag1() ==

  _*Description*_ lag1(arr) 
    arr is [ A ], 
    returns [ {prev: A, cur: A} ]
     
 If arr has k items, the result has k - 1 items.
 result[].prev is the first k-1 items
 result[].cur  is the last k-1 items.

 eg: [1,2,3] -> lag1()  ==  [ { prev: 1, cur: 2 }, { prev: 2, cur: 3 } ]

  _*Parameters*_ (1)

== merge() ==

  _*Description*_ DEPRECATED: use union instead.
 Union multiple arrays into one array in arbitrary order without
 removing duplicates (like SQL's UNION ALL)

  _*Parameters*_ (1 - 2)

== nextElement() ==

  _*Description*_ arr -> prevAndNextElement() 
    arr is [ T ], 
    returns [ { cur: T, prev?: T, next?: T } ]
     
 If arr has k items, the result has k items.
 The first record returned does not have a prev field.
 The last record returned does not have a next field.

 eg: [1,2,3] -> nextElement() ==  
  [ { cur: 1, next: 2 }, 
    { cur: 2, next: 3 }, 
    { cur: 3 } ]

  _*Parameters*_ (1)

== pair() ==

  _*Description*_ pair(A,B) == [A,B]

  _*Parameters*_ (2)

== pairwise() ==

  _*Description*_ 

  _*Parameters*_ (2 - 3)

== powerset() ==

  _*Description*_ powerset<T>([T...]? arr) returns [ [T...]... ] 
 Return the power-set (really the power-list) of a list of items.
     
 If arr has k items, the result has k - 1 items.
 result[].prev is the first k-1 items
 result[].cur  is the last k-1 items.

 eg: [1,2,3] -> powerset() ==  [ [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]

  _*Parameters*_ (1)

== prevAndNextElement() ==

  _*Description*_ arr -> prevAndNextElement() 
    arr is [ T ], 
    returns [ { cur: T, prev?: T, next?: T } ]
     
 If arr has k items, the result has k items.
 The first record returned does not have a prev field.
 The last record returned does not have a next field.

 eg: [1,2,3] -> prevAndNextElement() ==  
  [ { cur: 1, next: 2,  }, 
    { cur: 2, prev: 1, next: 3 }, 
    { cur: 3, prev: 2 } ]

  _*Parameters*_ (1)

== prevElement() ==

  _*Description*_ arr -> prevAndNextElement() 
    arr is [ T ], 
    returns [ { cur: T, prev?: T, next?: T } ]
     
 If arr has k items, the result has k items.
 The first record returned does not have a prev field.
 The last record returned does not have a next field.

 eg: [1,2,3] -> prevElement() ==  
  [ { cur: 1 }, 
    { cur: 2, prev: 1 }, 
    { cur: 3, prev: 2 } ]

  _*Parameters*_ (1)

== removeElement() ==

  _*Description*_ 

  _*Parameters*_ (2)

== replaceElement() ==

  _*Description*_ 

  _*Parameters*_ (3)

== reverse() ==

  _*Description*_ 

  _*Parameters*_ (1)

== rowwise() ==

  _*Description*_ 

  _*Parameters*_ (1)

== runningCombine() ==

  _*Description*_ 

  _*Parameters*_ (4)

== shift() ==

  _*Description*_ 

  _*Parameters*_ (3)

== slice() ==

  _*Description*_ 

  _*Parameters*_ (3)

== slidingWindow() ==

  _*Description*_ 

  _*Parameters*_ (3)

== slidingWindowBySize() ==

  _*Description*_ 

  _*Parameters*_ (2 - 4)

== toArray() ==

  _*Description*_ If the input is an array or null, return it; else wrap in an array.
 
 if( $x instanceof type [*<*>]? ) $x else [$x]

  _*Parameters*_ (1)

== tumblingWindow() ==

  _*Description*_ 

  _*Parameters*_ (2 - 5)

== tumblingWindowBySize() ==

  _*Description*_ 

  _*Parameters*_ (2 - 3)

== union() ==

  _*Description*_ Union multiple arrays into one array in arbitrary order without
 removing duplicates (like SQL's UNION ALL)

  _*Parameters*_ (1 - 2)

----
=index=
== buildJIndex() ==

  _*Description*_ 

  _*Parameters*_ (2)

== keyLookup() ==

  _*Description*_ [ [key,value1] ] -> keyLookup([ [key,value2] ]) ==> [ [key, value1, value2] ]
 
 Build a hash table on the inner key/value pairs (expr[1]).
 For each key/value in the outer pairs (expr[0])
   return [key, value1, value2] tuples.
   
 The code assumes that the inner keys are unique (or an arbitrary value is kept)
    //TODO: support duplicates?  raise error?
 
 If the outer key does not exist in the inner set, 
   null is returned for the inner value.
   So this is preserving the outer input (left outer join)
   // TODO: support full outer by finding inner values that didn't join?
 
   // TODO:support spilling large inners?

  _*Parameters*_ (2)

== keyMerge() ==

  _*Description*_ [ [key,value1] ] -> keyMerge([ [key,value2] ]) ==> [ [key, value1, value2] ]
 
 Both input lists are sorted by key.
 The inner list (expr[1]) is assumed to have distinct keys.
    //TODO: support duplicates?  raise error?
 For each key/value in the outer list (expr[0])
   return [key, value1, value2] tuples.
   
 This function only requires a single key from each list to be in memory at a time.

  _*Parameters*_ (2)

== probeJIndex() ==

  _*Description*_ 

  _*Parameters*_ (2)

== probeLongList() ==

  _*Description*_ [ [long? key, any value] ] -> probeLongListFn([ long? key ]) ==> [ [long key, any value, long index] ]
 
 Build a compact in-memory representation of a list of longs from the build keys (expr[1]).
   Nulls in the probe list are ignored and removed from the list.
 For each key/value in the probe pairs (expr[0])
   index is >= 0 if the value is found in the list of keys.
                (actually it index of the key in the sorted list of keys, but that may change in the future)
            < 0  if not found 
                (actually it is the (-(insertion point) - 1) as defined by Arrays.binarySearch(),
                 but that may change in the future)
   return [key, value, index] tuples.
   
 Note that all probe items are returned.
 This allows us to support in and not-in predicates, as well as just simple annotations.
 Nulls are tolerated in the probe keys, but they will never find a match.
 Null [key,value] pairs are not tolerated; a pair is always expected.

 There is currently an implementation limit of 2B values (~16GB of memory).

  _*Parameters*_ (2)

== sharedHashtableN() ==

  _*Description*_ sharedHashtableN(
     [Key] probeKeys,
     string buildUrl, // "hash://host:port/tableid",
     fn() returns [ [Key,Value] ] buildFn,
     schema [Key, Value] buildSchema ) // TODO: should be inferred from buildFn OR template params 
   returns [Key,Value]

 
 The file represented by fd must have [key,value2] pairs.
 The [key,value2] pairs are loaded into a hash table
 If the fd is same from call to call, the table is not reloaded.
   // TODO: cache multiple tables? perhaps with weak references
   // TODO: use hadoop's distributed cache?
   
 It is generally assumed that the file is assessible wherever this
 function is evaluated.  If it is automatically parallelized, the
 file better be available from every node (eg, in hdfs).

 Throws an exception if the file contains duplicate keys
 
 If the probe key does not exist in the hashtable, null is returned.

  _*Parameters*_ (4 - 10)

----
=xml=
== jsonToXml() ==

  _*Description*_ An expression for converting JSON to XML. It is called as follows:
 <code>jsonToXml()</code> . It is counterpart of {@link XmlToJsonFn}. But it
 does not perform a conversion which is reverse to the conversion in
 {@link XmlToJsonFn}. The reason is:
 <ol>
 <li>There is no concepts such as namespace in JSON</li>
 <li>The conversion is for a conversion from general JSON to XML. It is the
 commons case that the JSON to be converted is not converted from XML.</li>
 </ol>
 
 Only a JSON value satisfying the following conditions can be converted to
 XML:
 <ol>
 <li>It is a JSON record whose size is 1.</li>
 <li>The value of the only JSON pair in this JSON record is not JSON array.</li>
 </ol>
 
 An array nested in another array does not inherit the nesting array. For
 example, <code>{content: [[1, 2]]}</code> is converted to:
 
 <pre>
 &lt;content&gt;
   &lt;array&gt;1&lt;/array&gt;
   &lt;array&gt;2&lt;/array&gt;
 &lt;/content&gt;
 
 <pre>

  _*Parameters*_ (1)

== typedXmlToJson() ==

  _*Description*_ An expression for converting XML to JSON.
 This function is similar to xmlToJson, except that it creates typed data, i.e., instead of producing all values as strings, 
 		it tries to cast each value to a closest type.

  _*Parameters*_ (1)

== xmlToJson() ==

  _*Description*_ An expression for converting XML to JSON.

  _*Parameters*_ (1)

== xpath() ==

  _*Description*_ Runs XPath on an XML document.
 
 xpath(xml, xpath)

  _*Parameters*_ (2 - 3)

== xslt() ==

  _*Description*_ Runs XSLT on an XML document.
 
 xslt(xml, xsl)

  _*Parameters*_ (2)

----
=binary=
== base64() ==

  _*Description*_ Convert an ascii/utf8 base64 string into a binary string

  _*Parameters*_ (1)

== hex() ==

  _*Description*_ Convert a hexadecimal string into a binary string

  _*Parameters*_ (1)

----
=internal=
== exprtree() ==

  _*Description*_ An internal method that can be used to print the internal tree of expressions in JSON format.

  _*Parameters*_ (1)

== hash() ==

  _*Description*_ An internal method that can be used to print the internal tree of expressions in JSON format.

  _*Parameters*_ (1)

== longHash() ==

  _*Description*_ An internal method that can be used to print the internal tree of expressions in JSON format.

  _*Parameters*_ (1)

----
=regex=
== regex() ==

  _*Description*_ Create a regular expression (regex) value.

  _*Parameters*_ (1 - 2)

== regex_extract() ==

  _*Description*_ 

  _*Parameters*_ (2)

== regex_extract_all() ==

  _*Description*_ 

  _*Parameters*_ (2)

== regex_match() ==

  _*Description*_ 

  _*Parameters*_ (2)

== regex_spans() ==

  _*Description*_ 

  _*Parameters*_ (2)

== regex_test() ==

  _*Description*_ 

  _*Parameters*_ (2)

----
=date=
== date() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

== dateMillis() ==

  _*Description*_ 

  _*Parameters*_ (1)

== dateParts() ==

  _*Description*_ 

  _*Parameters*_ (1)

== now() ==

  _*Description*_ 

  _*Parameters*_ (0)

----
=nil=
== denull() ==

  _*Description*_ 

  _*Parameters*_ (1)

== emptyOnNull() ==

  _*Description*_ emptyOnNull(e) == firstNonNull(e, [])

  _*Parameters*_ (1)

== firstNonNull() ==

  _*Description*_ 

  _*Parameters*_ (0 - 1)

== nullElementOnEmpty() ==

  _*Description*_ 

  _*Parameters*_ (1)

== nullOnEmpty() ==

  _*Description*_ 

  _*Parameters*_ (1)

== onEmpty() ==

  _*Description*_ 

  _*Parameters*_ (2)

----
=catalog=
== catalogInsert() ==

  _*Description*_ An expression to insert an entry into catalog. It is an error if an entry
 with the same key already exists.

  _*Parameters*_ (1 - 2)

== catalogLookup() ==

  _*Description*_ An expression to read the entry identified by a key in catalog.

  _*Parameters*_ (1 - 2)

== catalogUpdate() ==

  _*Description*_ An expression to update catalog entry. It can only add records or fields. No
 old records or fields will be overwritten.

  _*Parameters*_ (1 - 2)

== updateComment() ==

  _*Description*_ An expression that updates comment field of entry in catalog.

  _*Parameters*_ (1)

----
=number=
== abs() ==

  _*Description*_ 

  _*Parameters*_ (1)

== decfloat() ==

  _*Description*_ 

  _*Parameters*_ (1)

== div() ==

  _*Description*_ 

  _*Parameters*_ (2)

== double() ==

  _*Description*_ 

  _*Parameters*_ (1)

== exp() ==

  _*Description*_ raise base of natural log (e) to arg: e^a pow(x,y) = exp( y * ln(x) )

  _*Parameters*_ (1)

== ln() ==

  _*Description*_ natural logarithm

  _*Parameters*_ (1)

== long() ==

  _*Description*_ 

  _*Parameters*_ (1)

== mod() ==

  _*Description*_ 

  _*Parameters*_ (2)

== number() ==

  _*Description*_ 

  _*Parameters*_ (1)

== pow() ==

  _*Description*_ raise a number to power

  _*Parameters*_ (2)

== toNumber() ==

  _*Description*_ 

  _*Parameters*_ (1)

----
=module=
== examples() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

== listExports() ==

  _*Description*_ 

  _*Parameters*_ (1)

== test() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

----
=random=
== randomDouble() ==

  _*Description*_ 

  _*Parameters*_ (0 - 1)

== randomLong() ==

  _*Description*_ 

  _*Parameters*_ (0 - 1)

== registerRNG() ==

  _*Description*_ 

  _*Parameters*_ (2)

== sample01RNG() ==

  _*Description*_ 

  _*Parameters*_ (1)

== sampleRNG() ==

  _*Description*_ 

  _*Parameters*_ (1)

== uuid() ==

  _*Description*_ Generate a type 4 UUID (random method)

  _*Parameters*_ (0)

----
=record=
== arity() ==

  _*Description*_ 

  _*Parameters*_ (1)

== fields() ==

  _*Description*_ 

  _*Parameters*_ (1)

== names() ==

  _*Description*_ names($rec) == for $k,$v in $rec return $k == fields($rec)[*][0];

  _*Parameters*_ (1)

== record() ==

  _*Description*_ 

  _*Parameters*_ (1)

== remap() ==

  _*Description*_ 

  _*Parameters*_ (2)

== removeFields() ==

  _*Description*_ 

  _*Parameters*_ (2)

== renameFields() ==

  _*Description*_ 

  _*Parameters*_ (2)

== replaceFields() ==

  _*Description*_ Replace fields in oldRec with fields in newRec only if the field name exists in oldRec.
 Unlike remap, this only replaces existing fields.

  _*Parameters*_ (1)

== values() ==

  _*Description*_ values($rec) == for $k,$v in $rec return $v == fields($rec)[*][1];

  _*Parameters*_ (1)

----
=del=
== jsonToDel() ==

  _*Description*_ A function for converting JSON to CSV. It is called as follows:
 <p>
 <code>jsonToDel({schema: '...', delimiter: '...', quoted: '...', escape: '...'})</code> .

  _*Parameters*_ (1 - 2)

----
=schema=
== assert() ==

  _*Description*_ Returns its first argument and adds the schema information given in the second argument
 without validation. Use carefully!

  _*Parameters*_ (2)

== check() ==

  _*Description*_ Checks whether the first argument matches the schema given in the second argument. If so,
 returns the first argument. Otherwise, throws an expection.

  _*Parameters*_ (2)

== dataGuide() ==

  _*Description*_ Usage: dataGuide(any value) returns [string]
 
 Return a string that represents each unique path in the value.
 For records:
    yield ""
    for each field:value in record:
       yield "." + field + dataGuide(value)
 For arrays:
    yield "[]"
    for each value in array
       yield "[]" + dataGuide(value) 
 For atomic types:
     yield ":" + the type name, eg, ":string", ":null"

  _*Parameters*_ (1)

== elementsOf() ==

  _*Description*_ elementsOf(schema): if schema is (potentially) an array schema, return the schema of its elements (if any)

  _*Parameters*_ (1)

== fieldsOf() ==

  _*Description*_ elementsOf(schema): if schema is (potentially) an record schema, return a table describing its known fields:
     [{ name: string, schema: schema, index: long }...]

  _*Parameters*_ (1)

== isNullable() ==

  _*Description*_ isNullable(schema): true if schema might match null, false otherwise

  _*Parameters*_ (1)

== schemaof() ==

  _*Description*_ 

  _*Parameters*_ (1)

== sqlTypeCode() ==

  _*Description*_ sqlTypeCode(schema): return the sql type code for schema

  _*Parameters*_ (1)

== typeof() ==

  _*Description*_ 

  _*Parameters*_ (1)

----
=agg=
== any() ==

  _*Description*_ Picks any value. If there is at least one non-null values, picks a non-null value.

  _*Parameters*_ (1)

== argmax() ==

  _*Description*_ 

  _*Parameters*_ (2)

== argmin() ==

  _*Description*_ 

  _*Parameters*_ (2)

== array() ==

  _*Description*_ 

  _*Parameters*_ (1)

== avg() ==

  _*Description*_ 

  _*Parameters*_ (1)

== combine() ==

  _*Description*_ 

  _*Parameters*_ (2)

== count() ==

  _*Description*_ 

  _*Parameters*_ (1)

== covStats() ==

  _*Description*_ covStats(array x) = sum [1 x1 x2 ... xn] * [1 x1 x2 ... xn]^T
   = [ count   sum(x1)    sum(x2)    ... sum(xn)    ,
               sum(x1*x1) sum(x1*x2) ... sum(x1*xn) ,
                          sum(x2*x2) ... sum(x2*xn) ,
       ...                                          ,
                                         sum(xn*xn) ]

  _*Parameters*_ (1)

== expSmooth() ==

  _*Description*_ Perform exponential smoothing on a sequence of numbers:
   s[0] = x[0]
   s[i] = a * x[i] + (1-a) * s[i-1]
 The numbers are cast to a double and the result is always a double.

  _*Parameters*_ (2)

== icebergCubeInMemory() ==

  _*Description*_ 

  _*Parameters*_ (3 - 4)

== inferElementSchema() ==

  _*Description*_ Infer a schema that describes all of the elements.

  _*Parameters*_ (1)

== javauda() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

== javaudacall() ==

  _*Description*_ 

  _*Parameters*_ (2 - 3)

== max() ==

  _*Description*_ 

  _*Parameters*_ (1)

== min() ==

  _*Description*_ 

  _*Parameters*_ (1)

== pickN() ==

  _*Description*_ 

  _*Parameters*_ (2)

== singleton() ==

  _*Description*_ Convert a pipe to a simple value:
   If the pipe is empty then null
   If the pipe has one item then that item
   If the pipe has more than one item then error

  _*Parameters*_ (1)

== sum() ==

  _*Description*_ 

  _*Parameters*_ (1)

== topN() ==

  _*Description*_ 

  _*Parameters*_ (3)

== uda() ==

  _*Description*_ 

  _*Parameters*_ (4)

== udacall() ==

  _*Description*_ 

  _*Parameters*_ (5)

== vectorSum() ==

  _*Description*_ vectorSum(array x) = [sum(x1), sum(x2), ..., sum(xn)]

  _*Parameters*_ (1)

----
=db=
== jdbc() ==

  _*Description*_ 

  _*Parameters*_ (1)

----
=span=
== span() ==

  _*Description*_ 

  _*Parameters*_ (2)

== span_begin() ==

  _*Description*_ 

  _*Parameters*_ (1)

== span_contains() ==

  _*Description*_ 

  _*Parameters*_ (2)

== span_end() ==

  _*Description*_ 

  _*Parameters*_ (1)

== span_extract() ==

  _*Description*_ span_extract("some big string", span(2,4))
 "me"
 
 Current implementation uses SubJsonString. If the caller modifies the input string at
 some later point, the result of this call will be invalid.

  _*Parameters*_ (2)

== span_overlaps() ==

  _*Description*_ 

  _*Parameters*_ (2)

== span_select() ==

  _*Description*_ 

  _*Parameters*_ (2)

== tokenize() ==

  _*Description*_ 

  _*Parameters*_ (1)

----
=string=
== convert() ==

  _*Description*_ Converts an input value (string, array of strings or record with string values) to 
 the specified types.

  _*Parameters*_ (2)

== endsWith() ==

  _*Description*_ 

  _*Parameters*_ (2)

== json() ==

  _*Description*_ 

  _*Parameters*_ (1)

== serialize() ==

  _*Description*_ 

  _*Parameters*_ (1)

== startsWith() ==

  _*Description*_ 

  _*Parameters*_ (2)

== strcat() ==

  _*Description*_ 

  _*Parameters*_ (0 - 1)

== strJoin() ==

  _*Description*_ string strJoin(array items, string sep) 
 Build a string that concatentates all the items, adding sep between each item.
 Nulls are removed, without any separator.
 If you want nulls, use firstNonNull(e,'how nulls appear').

  _*Parameters*_ (2)

== strLen() ==

  _*Description*_ Usage: long strLen(string str)

  _*Parameters*_ (1)

== strPos() ==

  _*Description*_ Usage: long strPos(string str, string toFind, long startIndex=0)

  _*Parameters*_ (2 - 3)

== strPosList() ==

  _*Description*_ Usage: long StrPosFn(string str, string toFind, long startIndex=0)

  _*Parameters*_ (2 - 3)

== strReplace() ==

  _*Description*_ Usage: [string] strReplace(string val, regex pattern, string replacement)

  _*Parameters*_ (3)

== strSplit() ==

  _*Description*_ Usage: [string] strSplit(string val, string delimitter)

  _*Parameters*_ (2)

== strSplitN() ==

  _*Description*_ strSplitN(string src, string sep, int n) ==> [string1, string2, ..., stringn]
 sep is a string of one charater.

  _*Parameters*_ (3)

== strToLowerCase() ==

  _*Description*_ Convert a string to lower case.

  _*Parameters*_ (1)

== strToUpperCase() ==

  _*Description*_ Convert a string to upper case.

  _*Parameters*_ (1)

== substring() ==

  _*Description*_ 

  _*Parameters*_ (2 - 3)

----
=function=
== addClassPath() ==

  _*Description*_ Add jars to the classpath

  _*Parameters*_ (1)

== fence() ==

  _*Description*_ 

  _*Parameters*_ (2)

== fencePush() ==

  _*Description*_ 

  _*Parameters*_ (2)

== javaudf() ==

  _*Description*_ An expression that constructs a JSON value for a Java UDF

  _*Parameters*_ (1)

----
=net=
== jaqlGet() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2)

----