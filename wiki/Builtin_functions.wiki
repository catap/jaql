#summary JAQL built-in function list - autogenerated
#labels generated
#sidebar TableOfContents
<wiki:toc max_depth="2" />
=system=
== externalfn() ==

  _*Description*_ An expression that constructs a JSON value for a Java UDF

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== ls() ==

  _*Description*_ ls(glob)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

----
=core=
== catch() ==

  _*Description*_ Wrap any expression with catch to guard against exceptions.
 Usage:
 
 T1|null catch( T1 e1, { errThresh: long } | null, T2 e2);
 
 Wrap the catch expression around the first argument, e1, that needs to be guarded
 for exceptions. 
 
 The second argument is optional. It specifies an exception handling policy. If unspecified or null, the default
 exception handling policy is used. By default, if an exception occurs, it is propagated
 (which typically results in aborted execution). This default can be overridden globally
 using the registerExceptionHandler function, or at can be overridden per usage of catch
 by using the second argument. Such an override allows catch to throw an exception errThresh
 times before propagating the exception. Thus, the default has errThresh set to 0.
 
 The third argument, e2, is optional and is used to specify an expression whose value is logged when an exception
 is thrown.
 
 Catch returns the result of evaluating e1 (whose type is T1). If an exception is thrown, but
 skipped, then null is returned.
 
 Note that catch s a "blocking" call: the result of e1 will be materialized. If e1 could
 be streamed (e.g., read(...)), when used in the context of catch, its result will be entirely
 materialized.

  _*Parameters*_ (1 - 3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any),( arg2 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> data = [ ["a",0], ["a",1], ["b",0], ["c",0], ["c",1], ["c",2]];

jaql> data -> write(hdfs("test"));

jaql> read(hdfs("test"))
      -> transform catch(if ($[0] == "a") ($.badFieldAccess) // cause exceptions on ["a", 0] and ["a", 1]
                         else ($), 
                         { errThresh: 1000 }) 
      -> group by g = $[0] 
         into { g: g, 
                num: count($), 
                err: catch(if(g == "b") (g.badFieldAccess) // cause exception/null on the "b" group
                           else ("ok"), 
                           { errThresh: 1000 }) 
              }; 
[
 {
   "err": "ok",
   "g": null,
   "num": 2
  },
  {
   "err": null,
   "g": "b",
   "num": 1
  },
  {
   "err": "ok",
   "g": "c",
   "num": 3
  }
]

}}}
== compare() ==

  _*Description*_ 

  _*Parameters*_ (2 inputs)
 Input Types: {{{( x, required: schema any),( y, required: schema any)}}}

 _*Output*_ {{{schema long}}}

== getHdfsPath() ==

  _*Description*_ return the absolute path in HDFS

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== getOptions() ==

  _*Description*_ Return Jaql's options as a record
 Usage:
 
 { *: any, *} getOptions();
 
 Jaql maintains globally accessible options, e.g., name-value pairs.
 These options are represented as a record; the getOptions function
 returns these options. Note that if you set the field "conf" with
 a record, those options are overlaid onto Hadoop's JobConf when a 
 MapReduce job is run. Using getOptions and setOptions, one can 
 override settings in the default JobConf.

  _*Parameters*_ (0 inputs)
 Input Types: {{{}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> getOptions();
 {
   "conf": {
     "io.sort.factor": 20
   }
 }

}}}
== index() ==

  _*Description*_ element(array, index) is the same as array[index], but it captures a simpler 
 case that doesn't use path expressions. array[index] is transformed to use the
 element function for better performance.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== listVariables() ==

  _*Description*_ List the active global variables.
   [{ var: string, schema: schema, isTable: boolean }...]

  _*Parameters*_ (0 inputs)
 Input Types: {{{}}}

 _*Output*_ {{{schema [
         {
           "var": string,
           "schema": schematype,
           "isTable": boolean
         } * 
       ]}}}

== perPartition() ==

  _*Description*_ 

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== range() ==

  _*Description*_ Range generates a continuous array of numbers
 
 Usage:
 range(size)      = [0,size-1]
 range(size,null) = [0,size-1]
 range(start,end) = [start,end]
 range(start,end,skip) = if skip > 0 then for(i = start, i <= end, i += skip)
                         else error
 range(size,null,skip) = if skip > 0 then for(i = 0, i < size, i += skip)
                         else error

  _*Parameters*_ (1 - 3 inputs)
 Input Types: {{{( startOrSize, required: schema long?),( end = null: schema long?),( by = 1: schema long)}}}

 _*Output*_ {{{schema [
         long * 
       ]}}}

== registerExceptionHandler() ==

  _*Description*_ Register a default exception handling policy.
 Usage:
 
 bool registerExceptionHandler( { errThresh: long } );
 
 This function allows the default exception handling policy to be overridden.
 Currently, the policy can specify how many exceptions to skip before propagating
 the exception up the call stack. This is specified by the errThresh field of the
 input. By default, errThresh is set to 0, meaning that no exceptions are skipped.
 
 When an exception is skipped, the enclosing expression decides what to do. If the
 exception occurs in the catch function, then it returns null and logs the results of
 a user supplied expression. If the exception occurs in a transform, then the result is
 skipped and logged.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> registerExceptionHandler({errThresh: 5});

jaql> data = [ ["a",0], ["a",1], ["b",0], ["c",0], ["c",1], ["c",2]];

jaql> data -> write(hdfs("test"));

jaql> read(hdfs("test")) -> filter $[1] == 0 -> transform $.badTypeAssumption;
 []

}}}
== setOptions() ==

  _*Description*_ Set Jaql's options as a record
 Usage:
 
 bool setOptions( {*: any, *} );
 
 Jaql maintains globally accessible options, e.g., name-value pairs.
 These options are represented as a record; the setOptions function
 modified these options. Note that if you set the field "conf" with
 a record, those options are overlaid onto Hadoop's JobConf when a 
 MapReduce job is run. Using getOptions and setOptions, one can 
 override settings in the default JobConf.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> setOptions( { conf: { "io.sort.factor": 20  }} );

}}}
== tee() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any)...}}}

 _*Output*_ {{{schema any}}}

== timeout() ==

  _*Description*_ Wrap any expression to limit the amount of time it will run.
 Usage:
 
 T timeout(T e, long millis);

 Given an arbitrary expression e (of type T), all it to be evaluated 
 for now more than millis ms. If e completes in less than millis time,
 then its value is returned. Otherwise, an exception is thrown.

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> sleep = javaudf("com.ibm.jaql.fail.fn.SleepFn"); // simple function where we can control its evaluation time

jaql> timeout(sleep(10000), 5000); // this should throw an exception

jaql> timeout(sleep(5000), 10000)); // this should complete successfully in 5 seconds

}}}
----
=hadoop=
== loadJobConf() ==

  _*Description*_ load a Hadoop JobConf into a record
 Usage: 
 { *: string, * } loadJobConf( string? filename )
 
 If filename to conf is not specified, then the default JobConf is loaded.

  _*Parameters*_ (0 - 1 inputs)
 Input Types: {{{( arg0 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

== mapReduce() ==

  _*Description*_ 

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== mrAggregate() ==

  _*Description*_ 

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== nativeMR() ==

  _*Description*_ launch a natively specified MapReduce job
 Usage: 
 { status: boolean } nativeMR( { job conf } conf , { apiVersion: "0.0" | "1.0", useSessionJar: boolean } options );
 
 Launch a stand-alone map-reduce job that is exclusively described by job conf settings.
 The conf can be obtained using loadJobConf or it can be specified using a record literal
 that lists the needed name/value pairs for the job. If apiVersion is set to "0.0", then
 the old Hadoop MapReduce API is used. Otherwise, the new API is used.
 
 The useSessionJar is convenient for those native MapReduce jobs that use jaql libraries.
 Since the jaql client already packages up jars when submitting jobs to Hadoop's MapReduce,
 the useSessionJar is used to specify that the job's jar should use the client's currently
 packaged jar.

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> nativeMR( loadJobConf( "myJob.conf" ) );
 { status: true }

}}}
== readConf() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

----
=io=
== hdfsShell() ==

  _*Description*_ An expression for running HDFS shell. It is equivalent to <i>hadoop fs</i>.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

----
=array=
== arrayToRecord() ==

  _*Description*_ 

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== deempty() ==

  _*Description*_ 

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== distinct() ==

  _*Description*_ List distinct values from an array, remove duplicates.
 
 Usage:
 [any] distinct( [any] )

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> distinct( [1, 1d, 1m, 1.5d, 1.5m, 1.50d, 1.50m ] ) -> sort by [$];
 [ 1,1.5 ]

}}}
== enumerate() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

== exists() ==

  _*Description*_ Usage : bool exists(any);
 If the argument is null, return null ,
 If the argument is a empty array , return false ,
 If the argument is an array with at least one element, return true ,
 If the argument is not an array or a null, return true.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> exists(null);
 null

jaql> exists([]);
 false

jaql> exists([...]);
 true //when the array has at least one element (even a null)

jaql> exists(...);
 true //when the argument is not an array or a null

}}}
== lag1() ==

  _*Description*_ lag1(arr) 
    arr is [ A ], 
    returns [ {prev: A, cur: A} ]
     
 If arr has k items, the result has k - 1 items.
 result[].prev is the first k-1 items
 result[].cur  is the last k-1 items.

 eg: [1,2,3] -> lag1()  ==  [ { prev: 1, cur: 2 }, { prev: 2, cur: 3 } ]

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== nextElement() ==

  _*Description*_ arr -> prevAndNextElement() 
    arr is [ T ], 
    returns [ { cur: T, prev?: T, next?: T } ]
     
 If arr has k items, the result has k items.
 The first record returned does not have a prev field.
 The last record returned does not have a next field.

 eg: [1,2,3] -> nextElement() ==  
  [ { cur: 1, next: 2 }, 
    { cur: 2, next: 3 }, 
    { cur: 3 } ]

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== pair() ==

  _*Description*_ Combines two values to an array. 
 
 Usage:
 array pair( any , any ); 
 
 The arguments can be any type of date, each of them will be one element of the return array.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> pair("element1", "element2");
 [ "element1" , "element2" ]

}}}
== pairwise() ==

  _*Description*_ Combine two arrays (A,B) into one array C, assume A = [ a1,a2,a3 ... ] , B = [ b1,b2,b3 ...] , pairwise combines every
 elements in the same position in each array, produces C = [ [a1,b1] , [a2,b2] , [a3,c3] ... ].
 
 Usage:
 array pairwise( array A , array B );

  _*Parameters*_ (2 - 3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2 = null: schema any)...}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> pairwise([1,2],[3,4]);
 [
  [1,3],
  [2,4]
 ]

}}}
== powerset() ==

  _*Description*_ powerset<T>([T...]? arr) returns [ [T...]... ] 
 Return the power-set (really the power-list) of a list of items.
     
 If arr has k items, the result has k - 1 items.
 result[].prev is the first k-1 items
 result[].cur  is the last k-1 items.

 eg: [1,2,3] -> powerset() ==  [ [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== prevAndNextElement() ==

  _*Description*_ arr -> prevAndNextElement() 
    arr is [ T ], 
    returns [ { cur: T, prev?: T, next?: T } ]
     
 If arr has k items, the result has k items.
 The first record returned does not have a prev field.
 The last record returned does not have a next field.

 eg: [1,2,3] -> prevAndNextElement() ==  
  [ { cur: 1, next: 2,  }, 
    { cur: 2, prev: 1, next: 3 }, 
    { cur: 3, prev: 2 } ]

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== prevElement() ==

  _*Description*_ arr -> prevAndNextElement() 
    arr is [ T ], 
    returns [ { cur: T, prev?: T, next?: T } ]
     
 If arr has k items, the result has k items.
 The first record returned does not have a prev field.
 The last record returned does not have a next field.

 eg: [1,2,3] -> prevElement() ==  
  [ { cur: 1 }, 
    { cur: 2, prev: 1 }, 
    { cur: 3, prev: 2 } ]

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== removeElement() ==

  _*Description*_ Remove element from array in the given position.
 
 Usage:
 array removeElement( array arr , int position);

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> removeElement([1,2,3],0);
 [ 2,3 ]

}}}
== replaceElement() ==

  _*Description*_ Replace an element of the target array with a given value.
 
 Usage :
 array replaceElement( array arr , int  position, value v );

  _*Parameters*_ (3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> replaceElement([1,2,3],2,100);
 [ 1,2,100 ]

}}}
== reverse() ==

  _*Description*_ Reverse an array
 
 Usage:
 array reverse(array arr)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> range(1,10) -> reverse();
  [ 10,9,8,7,6,5,4,3,2,1 ]

jaql> [[0],[1,2],[3,4,5],[6,7,8,9]] -> transform reverse($)->reverse();
 [ [9,8,7,6] , [5,4,3] , [2,1], [0] ] // reverse sequence

}}}
== shift() ==

  _*Description*_ 

  _*Parameters*_ (3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== slice() ==

  _*Description*_ 

  _*Parameters*_ (3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== slidingWindow() ==

  _*Description*_ 

  _*Parameters*_ (3 inputs)
 Input Types: {{{( input, required: schema [ * ]?),( start, required: schema function),( end, required: schema function)}}}

 _*Output*_ {{{schema [
         { * } * 
       ]}}}

== slidingWindowBySize() ==

  _*Description*_ 

  _*Parameters*_ (2 - 4 inputs)
 Input Types: {{{( input, required: schema [ * ]?),( size, required: schema long),( offset = null: schema long?),( exact = false: schema boolean)}}}

 _*Output*_ {{{schema [
         { * } * 
       ]}}}

== toArray() ==

  _*Description*_ If the input is an array or null, return it; else wrap in an array.
 
 if( $x instanceof type [*<*>]? ) $x else [$x]

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== tumblingWindow() ==

  _*Description*_ 

  _*Parameters*_ (2 - 5 inputs)
 Input Types: {{{( input, required: schema [ * ]?),( stop, required: schema function),( start = null: schema function?),( firstGroup = true: schema boolean?),( lastGroup = true: schema boolean?)}}}

 _*Output*_ {{{schema [
         [ * ] * 
       ]}}}

== tumblingWindowBySize() ==

  _*Description*_ 

  _*Parameters*_ (2 - 3 inputs)
 Input Types: {{{( input, required: schema [ * ]?),( size, required: schema long | double | decfloat),( lastGroup = true: schema boolean?)}}}

 _*Output*_ {{{schema [ * ]}}}

== union() ==

  _*Description*_ Union multiple arrays into one array in arbitrary order without
 removing duplicates (like SQL's UNION ALL)

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any)...}}}

 _*Output*_ {{{schema any}}}

----
=index=
== keyLookup() ==

  _*Description*_ [ [key,value1] ] -> keyLookup([ [key,value2] ]) ==> [ [key, value1, value2] ]
 
 Build a hash table on the inner key/value pairs (expr[1]).
 For each key/value in the outer pairs (expr[0])
   return [key, value1, value2] tuples.
   
 The code assumes that the inner keys are unique (or an arbitrary value is kept)
    //TODO: support duplicates?  raise error?
 
 If the outer key does not exist in the inner set, 
   null is returned for the inner value.
   So this is preserving the outer input (left outer join)
   // TODO: support full outer by finding inner values that didn't join?
 
   // TODO:support spilling large inners?

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== keyMerge() ==

  _*Description*_ [ [key,value1] ] -> keyMerge([ [key,value2] ]) ==> [ [key, value1, value2] ]
 
 Both input lists are sorted by key.
 The inner list (expr[1]) is assumed to have distinct keys.
    //TODO: support duplicates?  raise error?
 For each key/value in the outer list (expr[0])
   return [key, value1, value2] tuples.
   
 This function only requires a single key from each list to be in memory at a time.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== probeLongList() ==

  _*Description*_ [ [long? key, any value] ] -> probeLongListFn([ long? key ]) ==> [ [long key, any value, long index] ]
 
 Build a compact in-memory representation of a list of longs from the build keys (expr[1]).
   Nulls in the probe list are ignored and removed from the list.
 For each key/value in the probe pairs (expr[0])
   index is >= 0 if the value is found in the list of keys.
                (actually it index of the key in the sorted list of keys, but that may change in the future)
            < 0  if not found 
                (actually it is the (-(insertion point) - 1) as defined by Arrays.binarySearch(),
                 but that may change in the future)
   return [key, value, index] tuples.
   
 Note that all probe items are returned.
 This allows us to support in and not-in predicates, as well as just simple annotations.
 Nulls are tolerated in the probe keys, but they will never find a match.
 Null [key,value] pairs are not tolerated; a pair is always expected.

 There is currently an implementation limit of 2B values (~16GB of memory).

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

----
=schema=
== check() ==

  _*Description*_ Checks whether the first argument matches the schema given in the second argument. If so,
 returns the first argument. Otherwise, throws an expection.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== typeof() ==

  _*Description*_ 

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

----
=xml=
== jsonToXml() ==

  _*Description*_ An expression for converting JSON to XML. It is called as follows:
 <code>jsonToXml()</code> . It is counterpart of {@link XmlToJsonFn}. But it
 does not perform a conversion which is reverse to the conversion in
 {@link XmlToJsonFn}. The reason is:
 <ol>
 <li>There is no concepts such as namespace in JSON</li>
 <li>The conversion is for a conversion from general JSON to XML. It is the
 commons case that the JSON to be converted is not converted from XML.</li>
 </ol>
 
 Only a JSON value satisfying the following conditions can be converted to
 XML:
 <ol>
 <li>It is a JSON record whose size is 1.</li>
 <li>The value of the only JSON pair in this JSON record is not JSON array.</li>
 </ol>
 
 An array nested in another array does not inherit the nesting array. For
 example, <code>{content: [[1, 2]]}</code> is converted to:
 
 <pre>
 &lt;content&gt;
   &lt;array&gt;1&lt;/array&gt;
   &lt;array&gt;2&lt;/array&gt;
 &lt;/content&gt;
 
 <pre>

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== typedXmlToJson() ==

  _*Description*_ An expression for converting XML to JSON.
 This function is similar to xmlToJson, except that it creates typed data, i.e., instead of producing all values as strings, 
 		it tries to cast each value to a closest type.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== xmlToJson() ==

  _*Description*_ An expression for converting XML to JSON.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== xpath() ==

  _*Description*_ Runs XPath on an XML document.
 
 xpath(xml, xpath)

  _*Parameters*_ (2 - 3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

== xslt() ==

  _*Description*_ Runs XSLT on an XML document.
 
 xslt(xml, xsl)

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

----
=regex=
== regex() ==

  _*Description*_ Create a regular expression (regex).
 
 Usage:
 regex regex(string reg)
 
 regex(string reg) defines a regular expression, specified by a string, the regular-expression constructs complies
 with standard java.

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> reg = regex("[a-z]+"); regex_match(reg,"abc bcd");
 ["abc"]

}}}
== regex_extract() ==

  _*Description*_ Capture every first substrings which match each group (A group is a pair of parentheses used to 
 group subpatterns.) specified in the regular expression. Return a string array like :
  ["match_group1", "match_group2" , "match_group3" ...]
 
 Usage:
 [string] regex_extract(regex reg, string text)
 
 reg is the regular expression, text is the target string. For example, given a regular expression
   (a(b*))+(c*)
 it contains 3 groups:
   group 1: (a(b*)) 
   group 2: (b*) 
   group 3: (c*)
 if input is "abbabcd", by use of regex_extract function, substrings matches each group(1-3) will be captured, this function
 will return a string array, like
   [ "ab", "b", "c"]
 where "ab" is the first hit matches group 1, as well as "b" to group 2, "c" to group 3.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> regex_extract(regex("(a(b*))+(c*)"),"abbabcd");
 [ "ab", "b", "c"]

jaql> regex_extract(regex("(a(b*))"),"abbabcd");
 [ "abb", "bb"]

}}}
== regex_extract_all() ==

  _*Description*_ Capture all the substrings which match each group (A group is a pair of parentheses used to 
 group subpatterns.) specified in the regular expression. Return a string array like 
  [[match1_group1, match1_group2 ...] , [match2_group1, match2_group2] ... ]
 
 Usage:
 [string] regex_extract(regex reg, string text)
 
 regex_extract_all(regex("(a(b*))"),"abbabcd");
 
 reg is the regular expression, text is the target string. For example, given a regular expression
   (a(b*))
 it contains 3 groups:
   group 1: (a(b*)) 
   group 2: (b*) 
 if input is "abbabcd", by use of regex_extract function, substrings matches each group(1-2) will be captured, this function
 will return a string array, like
  [ 
   ["abb","bb"],
   ["ab","b"]
  ]

 where "abb" and "bb" is the first match of group 1 and 2 when scaning the text, "ab" and "b" is the second(last) match.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> regex_extract_all(regex("(a(b*))+(c*)"),"abbabcd");
 [ 
  [ "ab", "b", "c"]
 ]

jaql> regex_extract_all(regex("(a(b*))"),"abbabcd");
  [ 
   ["abb","bb"],
   ["ab","b"]
  ]

}}}
== regex_match() ==

  _*Description*_ Returns the first substring in input that matches the pattern against the regular expression.
 
 Usage:
 
 regex_match(regex reg , string text)
 
 reg is the regular expression, text is the target string.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> regex_match(regex("[a-z]?"),"abbabcd");
 "a" //this example performs a non-greedy matching

jaql> regex_match(regex("[a-z]*"),"abbabcd");
 "abbabcd"//this example performs a greedy matching

}}}
== regex_spans() ==

  _*Description*_ 

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== regex_test() ==

  _*Description*_ Check if the target string contains substring matches given regular expression. 
 If exist at least 1 match, return true, else return false
 
 Usage:
 bool regex_test(regex reg , string text)

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> regex_test(regex("[a-z]?"),"abbabcd");
 true

jaql> regex_test(regex("aaa"),"abbabcd");
 false

}}}
----
=binary=
== base64() ==

  _*Description*_ Convert an ascii/utf8 base64 string into a binary string.
  
  Usage:
  binary base64(string str)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> base64("utf8string");
  hex('BAD7FCB2DAE20000')

}}}
== hex() ==

  _*Description*_ Convert a hexadecimal string into a binary string.
  
  Usage:
  binary hex(string str)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

----
=date=
== date() ==

  _*Description*_ Format a string to date value.
 
 Usage:
 date date(string datestr)

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> date('2000-01-01T11:59:59Z');
 date('2000-01-01T12:00:00.000Z');

}}}
== dateMillis() ==

  _*Description*_ Represent the date using milliseconds.
 
 Usage:
 long dateMillis(date d)
 
 the argument is restricted with date type, or it causes bad casting exception.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> dateMillis(date('2000-01-01T12:00:00Z'));
 946728000000

}}}
== dateParts() ==

  _*Description*_ Return a record which stores all readable fields of a date, including year, montch, day, dayofweek ... e.g. 
 
 Usage:
 
 record dateParts(date d)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> dateParts(date('2000-01-01T12:00:00Z'));
 {
 "day": 1,
 "dayOfWeek": 6,
 "hour": 12,
 "millis": 946728000000,
 "minute": 0,
 "month": 1,
 "second": 0,
 "year": 2000,
 "zoneOffset": 0
 }

}}}
== now() ==

  _*Description*_ Return current system date time.
 
 Usage:
 date now()

  _*Parameters*_ (0 inputs)
 Input Types: {{{}}}

 _*Output*_ {{{schema any}}}

----
=nil=
== denull() ==

  _*Description*_ remove nulls from a given array
 Usage:
 [T] denull([T]);

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> denull( [1, null, 3] );
 [ 1, 3 ]

}}}
----
=agg=
== any() ==

  _*Description*_ Picks any value. If there is at least one non-null values, picks a non-null value.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( a, required: schema [ * ]?)}}}

 _*Output*_ {{{schema any}}}

== argmax() ==

  _*Description*_ 

  _*Parameters*_ (2 inputs)
 Input Types: {{{( a, required: schema [ * ]?),( f, required: schema function)}}}

 _*Output*_ {{{schema any}}}

== argmin() ==

  _*Description*_ 

  _*Parameters*_ (2 inputs)
 Input Types: {{{( a, required: schema [ * ]?),( f, required: schema function)}}}

 _*Output*_ {{{schema any}}}

== array() ==

  _*Description*_ 

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== avg() ==

  _*Description*_ 

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== count() ==

  _*Description*_ 

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== javauda() ==

  _*Description*_ 

  _*Parameters*_ (1 - 2 inputs)
 Input Types: {{{( class, required: schema string),( args = null: schema any)...}}}

 _*Output*_ {{{schema function}}}

== javaudacall() ==

  _*Description*_ 

  _*Parameters*_ (2 - 3 inputs)
 Input Types: {{{( array, required: schema [ * ]?),( class, required: schema string),( args = null: schema any)...}}}

 _*Output*_ {{{schema any}}}

== max() ==

  _*Description*_ Find the max value in an array.
 Usage:
 
 any max( [ any ] );
 
 Max takes an array as input and returns the max value from the array. The type of the array's elements is not restricted.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> max([1,2,3]);
 3

jaql> max(["a","b","c"]);
 "c"

jaql> read(hdfs("someFileOfLongs")) -> group into max($);

jaql> read(hdfs("someFileOfPairs")) -> group by g = $[0] into { first: g, maxSecond: max($[*][1]) };

}}}
== min() ==

  _*Description*_ Find the minimum value in an array.
 Usage:
 
 any max( [ any ] );
 
 Max takes an array as input and returns the minimum value from the array. The type of the array's elements is not restricted.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> min([1,2,3]);
 1

jaql> min(["a","b","c"]);
 "a"

jaql> read(hdfs("someFileOfLongs")) -> group into min($);

jaql> read(hdfs("someFileOfPairs")) -> group by g = $[0] into { first: g, minSecond: min($[*][1]) };

}}}
== pickN() ==

  _*Description*_ select N elements from an array
 Usage:
 [T] pickN( [T], long n );
 
 Select n elements from the input array.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> pickN( [1,2,3], 2 )
 [1,2]

}}}
== singleton() ==

  _*Description*_ ensure that an array has only one element, otherwise, throw an exception
 Usage:
 T singleton( [T] );

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> [1] -> singleton
 1

jaql> [1,2] -> singleton // throws an exception

}}}
== sum() ==

  _*Description*_ compute the sum of an array of numbers
 Usage:
 number sum( [ number ] );
 
 Note that sum is currently evaluated using a sequential plan.
 To get parallelism, use group by:

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> read(hdfs("someNumbers")) -> group into sum($);

}}}
== topN() ==

  _*Description*_ compute the top N values from an array
 Usage:
 [T] topN( [T], long n, cmp(x) );
 
 Given an input array, a limit n, and a comparator function, compute the top n elements
 of the input array. This implementation uses a heap to efficiently use memory and lower
 the network traffic that is needed for aggregation.

  _*Parameters*_ (3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> [1,2,3] -> write(hdfs("test1"));

jaql> read(hdfs("test1")) -> topN( 2, cmp(x) [x desc ] ); // Simplest example
 [ 1, 2 ]

jaql> read(hdfs("test1")) -> group into topN( $, 2, cmp(x) [ x desc ] ); // Now, with group by (this uses map-reduce)

jaql> [ [ 1, 1 ], [1, 2], [2, 0], [2, 11], [3, 3], [3, 4], [3, 5] ] -> write(hdfs("test2"));

jaql> read(hdfs("test2")) -> group by n = $[0] into { num: n, top: topN($[*][1], 1, cmp(x) [ x desc ]) }; // Complex data

}}}
== uda() ==

  _*Description*_ 

  _*Parameters*_ (4 inputs)
 Input Types: {{{( init, required: schema function),( accumulate, required: schema function),( combine, required: schema function),( final, required: schema function)}}}

 _*Output*_ {{{schema function}}}

== udacall() ==

  _*Description*_ 

  _*Parameters*_ (5 inputs)
 Input Types: {{{( array, required: schema [ * ]?),( init, required: schema function),( accumulate, required: schema function),( combine, required: schema function),( final, required: schema function)}}}

 _*Output*_ {{{schema any}}}

----
=number=
== abs() ==

  _*Description*_ Return the absolute value of a numeric value
 
 Usage:
 number abs(number)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> abs(-100);
 100

jaql> abs(-3.14)
 3.14

}}}
== decfloat() ==

  _*Description*_ Define a decfloat value

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> decfloat(5m);
 5m

jaql> 5m instanceof schema decfloat(value=5m);
 true

}}}
== div() ==

  _*Description*_ div(A,B) divides A by B, return a numric value.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> div(4,2);
 2

}}}
== double() ==

  _*Description*_ Get the double value of a numric value.
 
 Usage:
 double double(number A);

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> 22d instanceof schema double;
 true

jaql> double(5);
 5.0

jaql> double(5m);
 5.0

jaql> double(5d);
 5.0

}}}
== exp() ==

  _*Description*_ raise base of natural log (e) to arg: e^a pow(x,y) = exp( y * ln(x) )

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== ln() ==

  _*Description*_ Return the natural logarithm of a numeric value
 
 Usage:
 number abs(number)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== long() ==

  _*Description*_ Parse the given atom value to long value
 
 Usage:
 long long(anyatom)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> long(3.14)
 3

jaql> long(3)
 3

jaql> long(true)
 1

}}}
== mod() ==

  _*Description*_ Return the modulus of a and b, both a and b are numeric values 
 
 Usage:
 number mod(number a, number b)

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> mod(3,2)
 1

}}}
== pow() ==

  _*Description*_ Raise a number to power
 
 Usage:
 number pow(number a , number b)

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> mod(3,2)
 1

}}}
== toNumber() ==

  _*Description*_ convert a value to number
 Usage:
 number toNumber( e );
 
 Currently, this function converts booleans and strings.
 If a number is given as input, it returned verbatim.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

----
=string=
== convert() ==

  _*Description*_ Converts an input value (string, array of strings or record with string values) to the specified types. 
 Usage:
 T convert( string s, schema T );

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== endsWith() ==

  _*Description*_ test whether a string has a given suffix
 Usage:
 bool endsWith( string s, string suffix )

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== json() ==

  _*Description*_ convert a string in json format into jaql's data model
 Usage:
 any json( string json );

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> json( "[1,2,3]" );
 [1,2,3]

}}}
== serialize() ==

  _*Description*_ return a sctring representation of any value
 Usage:
 string serialze( value );

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== startsWith() ==

  _*Description*_ bool startsWith(string target, string prefix)
  Check if a target string starts with a given prefix, return true or false

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== strcat() ==

  _*Description*_ Concats one or more strings to a new string
 
 Usage:
 string strcat(string ... str)

  _*Parameters*_ (0 - 1 inputs)
 Input Types: {{{( arg0 = null: schema any)...}}}

 _*Output*_ {{{schema any}}}

== strJoin() ==

  _*Description*_ Build a string that concatentates all the items, adding sep between each item.
 Nulls are removed, without any separator.
 If you want nulls, use firstNonNull(e,'how nulls appear').
 
 Usage:
 string strJoin(array items, string sep)

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== strLen() ==

  _*Description*_ long strLen(string str)
 return the lenght of the given string

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== strPos() ==

  _*Description*_ Usage: long strPos(string str, string toFind, long startIndex=0)

  _*Parameters*_ (2 - 3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

== strPosList() ==

  _*Description*_ Usage: long StrPosFn(string str, string toFind, long startIndex=0)

  _*Parameters*_ (2 - 3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

== strReplace() ==

  _*Description*_ Replace a substring with the replacement only if it matches the given regular expression (regex).
 Usage: 
 [string] strReplace(string val, regex pattern, string replacement)

  _*Parameters*_ (3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> reg=regex("[a-z]+"); // define a regular expression, match at least one character.
 val = "<abc>,<bcd>,<cde>"; // deine a string 
 strReplace(str,reg,"a"); // replace all the match substrings with "a"
 
 "<a>,<a>,<a>"

}}}
== strSplit() ==

  _*Description*_ Split a string with given delimiter.
 Usage:
 [string] strSplit(string val, string delimiter);

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> strSplit("a,b,c,d",",");
 [ "a","b","c","d" ]

}}}
== strToLowerCase() ==

  _*Description*_ Convert a string to lower case.
 
 Usage:
 string strToLowerCase(string val)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> strToLowerCase("aBcDEFgHiJ");
 "abcdefghij"

}}}
== strToUpperCase() ==

  _*Description*_ Convert a string to upper case.
 
 Usage:
 string strToUpperCase(string val)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> strToUpperCase("abcDEFgHijk");
 "ABCDEFGHIJK"

}}}
== substring() ==

  _*Description*_ Get a certain substring of a string, start from beginIdx , end to endIdx. If endIdx is not given or larger 
 than the lenght of the string, return the substring from beginIdx to the end of the string.
 
 Usage:
 string substring(string val, int beginIdx, int endIndx ?);

  _*Parameters*_ (2 - 3 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any),( arg2 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> substring("I love the game", 2, 7);
 "love"

jaql> substring("I love the game", 2);
 "love the game"

jaql> substring("I love the game", 2, 20);
 "love the game"

}}}
----
=function=
== fence() ==

  _*Description*_ evaluate a function in a separate process
 Usage:
 [T2] fence( [T1],  T2 fn(T1 x) );

 The fence function applies the function argument to each element of
 the input array to produce the output array. In particular, the fence
 function is evaluated in a separate process. A common use of fence is
 to shield the Jaql interpreter from user-defined functions that exhaust
 memory, for example.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> [1,2,3] -> write(hdfs("test"));

jaql> read(hdfs("test")) -> fence( fn(i) i + 1 );
 [2,3,4]

}}}
== javaudf() ==

  _*Description*_ construct a jaql function from a given class
 Usage:
 fn javaudf( string className );
 
 The javaudf function constructs a function that knows how to evaluate itself
 given a className that specifies its body. The function can then be assigned
 to a variable (like any other value) and invoked (like any other function). 
 This is the primary means by which users can supply user-defined functions.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> split = javaudf("com.acme.extensions.fn.Split1"); // define the function and assign it to the variable split

jaql> path = '/home/mystuff/stuff';

jaql> split1(path, "/"); // invoke the split function

}}}
----
=random=
== randomDouble() ==

  _*Description*_ return a uniformly distributed double value between 0.0 (inclusive) and 1.0 (exclusive)
 Usage:
 double randomDouble( long? seed )
 
 The optional seed parameter is used to seed the internally used random number generator.
 
 Note: randomDouble will produce a pseudo-random sequence of doubles when called in sequence.
 If its called by multiple processes, in parallel (as done in MapReduce), then there are no
 guarantees (and in fact, if all sequential instances use the same seed, you'll get common
 prefixes).

  _*Parameters*_ (0 - 1 inputs)
 Input Types: {{{( arg0 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

== randomLong() ==

  _*Description*_ return a uniformly distributed long value 
 Usage:
 long randomLong( long? seed )
 
 The optional seed parameter is used to seed the internally used random number generator.
 
 Note: randomLong will produce a pseudo-random sequence of longs when called in sequence.
 If its called by multiple processes, in parallel (as done in MapReduce), then there are no
 guarantees (and in fact, if all sequential instances use the same seed, you'll get common
 prefixes).

  _*Parameters*_ (0 - 1 inputs)
 Input Types: {{{( arg0 = null: schema any)}}}

 _*Output*_ {{{schema any}}}

== registerRNG() ==

  _*Description*_ register a random number generator
 Usage:
 key registerRNG( key, long seed );
 
 Register an RNG with a given name, key, and a seed.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== sample01RNG() ==

  _*Description*_ return a uniformly distributed double value between 0.0 (inclusive) and 1.0 (exclusive) from a registered RNG
 Usage:
 double sample01RNG( string key )
 
 An RNG associated with key must have been previously registered using registerRNG.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== sampleRNG() ==

  _*Description*_ return a uniformly distributed long value from a registered RNG
 Usage:
 long sampleRNG( string key )
 
 An RNG associated with key must have been previously registered using registerRNG.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

== uuid() ==

  _*Description*_ Generate a type 4 UUID (random method)
 Usage:
 binary uuid()

  _*Parameters*_ (0 inputs)
 Input Types: {{{}}}

 _*Output*_ {{{schema any}}}

----
=record=
== arity() ==

  _*Description*_ Return the size of a record.
 
 Usage :
 long arity(record r);

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> arity({a:1,b:2,c:3});
 3

}}}
== fields() ==

  _*Description*_ Convert each key-value pair of a record to a [key,value] array.
 
 Usage:
 array fields(record r)

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> fields({a:1, b:2, c:3});
 [ ["a",1] , ["b",2] , ["c",3] ]

jaql> fields({a:1, b:2, c:3}) -> transform $[0];
 [ "a","b","c" ] //this example indicates a way to extract all the key values in a record.

}}}
== names() ==

  _*Description*_ Extract all the keys in a record and return as an array.
 names($rec) == for $k,$v in $rec return $k == fields($rec)[*][0];

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> names({a:1, b:2, c:3});
 [ "a","b","c" ]

}}}
== record() ==

  _*Description*_ Convert a array to a single record. 
 
 Usage:
 record record(array arr);
 
 the argument arr will be like [record1,record2,record3...], it has restricted format since a record can not contain any 
 duplicate keys, so this function asserts record1, record2 ... contains no same keys.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> record([{A:11},{B:22}]);
 {
  "A": 11,
  "B": 22
 }

}}}
== remap() ==

  _*Description*_ Join two records.
 
 Usage:
 record remap(record old, record new)
 
 remap joins two records, old and new together, produce a new record and return, remove duplicate key-values of old record.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> remap({a:1,b:2},{a:3,d:4});
 {
   "a" : 3, 
   "b" : 2,
   "d" : 4
 }

}}}
== removeFields() ==

  _*Description*_ Remove fields of a record by keys.
 
 Usage:
 record removeFields(record target, array names);
 
 names is an array with one or more string key names, removeFields will remove fields in target record if its key appears in names.

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> removeFields({a:1,b:2},["a"]);
 {
  "b":2
 }

}}}
== renameFields() ==

  _*Description*_ Replace the key of the target record with newName only if whose key equals with oldName.
 Usage:
 record renameFields(record target, record {oldName : newName , ...} );

  _*Parameters*_ (2 inputs)
 Input Types: {{{( arg0, required: schema any),( arg1, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> renameFields({a:1,b:2},{"a":"AAA" , "b":'BBB'});
 {
  "AAA": 1,
  "BBB": 2
 }

}}}
== replaceFields() ==

  _*Description*_ Replace fields in oldRec with fields in newRec only if the field name exists in oldRec.
 Unlike remap, this only replaces existing fields.

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> 

}}}
== values() ==

  _*Description*_ Extract all the values in a record and return as an array.
  values($rec) == for $k,$v in $rec return $v == fields($rec)[*][1];

  _*Parameters*_ (1 inputs)
 Input Types: {{{( arg0, required: schema any)}}}

 _*Output*_ {{{schema any}}}

  _*Examples*_ 
{{{
jaql> values({a:1, b:2, c:3});
  [ 1,2,3 ]

}}}
----