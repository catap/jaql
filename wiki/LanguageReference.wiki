#summary Jaql Language Reference

= Introduction =

Jaql is a functional language that is specialized for processing large collections of semi-structured data. The DataModel describes the values, as well as the schema constraints that are supported by Jaql. Every type has a textual representation that is based on JSON. There are many other representations available for (de)serializing values to and from byte streams (see [IO]). The textual representation is used as a convenient way to show results to the user in the shell and it is used to construct new values:

{{{
  // 1. print the result of the function 'range'
  jaql> range(1,3);
  [ 1,2,3 ]

  // 2. make a new array of records
  jaql> [ { a: 1 }, { a: 2 }, { a: 3 } ];
  [ { a: 1 }, { a: 2 }, { a: 3 } ]

  // 3. do the same by creating a record for each input element
  jaql> range(1,3) -> transform { a: $ };
  [ { a: 1 }, { a: 2 }, { a: 3 } ]
}}}

The example above also shows how to call a function ({{{range}}})
and how to operate on collections, which are interchangeably referred to as arrays ({{{transform}}}). For a comprehensive list of functions
that Jaql supports, see [Builtin_functions builtins] (and [Builtin_functions_experimental experimental builtins]). For a comprehensive list of operators that are specifically designed to process large arrays, please see LanguageCore. If further extensions are required, Jaql can easily be 
extended with Jaql [Functions], Java functions, or arbitrary [Builtin_functions#externalfn() executables]. Such extensions can be bundled into separate Jaql scripts called [Modules modules] which can be re-used.

In this document, we review Jaql's top-level statements and expressions.

= Top-level Statements =

 * Import
 * Assignment
 * Expression
 * Explain
 * Quit

= Import =
The {{{import}}} statement is used for loading modules into the current session's context. Following the {{{import}}} statement, all of the imported module's variables can be used. See [Modules modules] for more information.

= Assignment =

Jaql allows variables to be declared and assigned to either expressions or values. If a variable is assigned to an expression, there is no guarantee as to whether that expression has been evaluated (lazy evaluation or views). If a variable is assigned to a value, that value is materialized and stored in the session process's memory. Note that assignment is only as top-level statements; they are not permitted within function blocks, for example. Here are some examples:

{{{
  // assign a to the 'read' expression. no data is actually read.
  a = read(del("very_big_file"));

  // assign b to the value 1.
  b := 1;
}}}

If a variable is assigned to another variable, e.g., {{{x = y;}}}, {{{x}}} is assigned to the value or expression that {{{y}}} references.
For example:

{{{
  x = 1;
  y = x;
  x = 2;
  y; // prints out 1
  x; // prints out 2
}}}

In addition, Jaql supports {{{extern}}} variables that can be undefined. If an undefined variable is used, an error is thrown.

{{{
  extern x := 1;
}}}

Finally, types can be specified for variables:

{{{
  x: string = "foo";

  x: long := 1;
}}}

= Expression =

== Constructors ==
Take some of this from the data model section or link to it.

=== Record ===

Record values are constructed using braces {}. Literal records in JSON notation may be used. 
The quotes for field names may be omitted if the field name looks like an identifier, i.e. does not contain spaces or symbols.

Instead of literal field names and field values, nested subexpressions may be used. If a field name or field name expression is followed by ?, the field is only added to the record if its value is not null.

For convenience, a number of syntactic shortcuts for common constructs are provided.

 * If an in-scope variable is used in place of a field definition, a field is added to the record with the variable name as field name, and the variable value as field value. 
 * If a [Path_Expressions path] is used as a field definition, the resulting field will have the name of the final step of the path. 
 * A path expression that returns a record and is followed by {{{.*}}} will cause all fields of that record  to be copied to the constructed record.
 * If the : in one or more field definitions is followed by {{{flatten}}}, an array of records will be produced that contains one record for each element of the cross product of the {{{flatten}}}ed values. A record expression like this {{{ { ..., f1: flatten e1, f2 : flatten e2, ... , fn: flatten en,...}}} is equivalent to {{{ for( v1 in e1, v2 in e2, ..., vn in en) {..., f1: v1, f2: v2, ..., fn: vn,...} }}}. 

{{{
// literal record
{ x: "value", y: 12, "field with spaces" : 34.2}
// record with subexpressions for field values
basename="test";
{ filename: basename+".txt", size: count(somevariable)};
// record with subexpressions for field names
{ ("a"+"field"):  null, (basename) : "hi" }
// omit null fields (yields {required: null} as a result)
{ required: null, optional?: null}
// variable as field (yields { basename: "test"}
{basename} 
// path expressions
x={a: "value", b: "value"};
{ x.a } // copy field a from x
{x.*} // copy all fields from x
}}}

=== Array ===

== Arithmetic Expressions ==
TODO

== Boolean Expressions ==
TODO

== Path Expressions ==
TODO

== Blocks ==
TODO

== If-Then-Else ==
TODO

== Pipe and Function ==

Take from data model section for functions.
Pipe TODO.

== Partitioned Array Expressions ==

Link to JaqlCore.