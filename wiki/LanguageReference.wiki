#summary Jaql Language Reference

= Introduction =

Jaql is a functional language that is specialized for processing large collections of semi-structured data. The DataModel describes the values, as well as the schema constraints that are supported by Jaql. Every type has a textual representation that is based on JSON. There are many other representations available for (de)serializing values to and from byte streams (see IO). The textual representation is used as a convenient way to show results to the user in the shell and it is used to construct new values:

{{{
  // 1. print the result of the function 'range'
  jaql> range(1,3);
  [ 1,2,3 ]

  // 2. make a new array of records
  jaql> [ { a: 1 }, { a: 2 }, { a: 3 } ];
  [ { a: 1 }, { a: 2 }, { a: 3 } ]

  // 3. do the same by creating a record for each input element
  jaql> range(1,3) -> transform { a: $ };
  [ { a: 1 }, { a: 2 }, { a: 3 } ]
}}}

The example above also shows how to call a function ({{{range}}})
and how to operate on collections, which are interchangeably referred to as arrays ({{{transform}}}). For a comprehensive list of functions
that Jaql supports, see Builtin_functions (and Builtin_functions_experimental). For a comprehensive list of operators that are specifically designed to process large arrays, please see LanguageCore. If further extensions are required, Jaql can easily be 
extended with Jaql Functions, java functions, or arbitrary executables ([Builtin_functions#externalfn() externalfn] ).

= Top-level Statements =

 * Import (link to Modules)
 * Assignment
 * Expression
 * Explain
 * Quit

= Assignment =

Define the different types of variables.

= Expression =

== Constructors ==
Take some of this from the data model section or link to it.

=== Record ===

Record values are constructed using braces {}. Literal records in JSON notation may be used. 
The quotes for field names may be omitted if the field name looks like an identifier, i.e. does not contain spaces or symbols.

Instead of literal field names and field values, nested subexpressions may be used. If a field name or field name expression is followed by ?, the field is only added to the record if its value is not null.

For convenience, a number of syntactic shortcuts for common constructs are provided.

 * If an in-scope variable is used in place of a field definition, a field is added to the record with the variable name as field name, and the variable value as field value. 
 * If a [Path_Expressions path] is used as a field definition, the resulting field will have the name of the final step of the path. 
 * A path expression that returns a record and is followed by {{{.*}}} will cause all fields of that record  to be copied to the constructed record.
 * If the : in one or more field definitions is followed by {{{flatten}}}, an array of records will be produced that contains one record for each element of the cross product of the {{{flatten}}}ed values. A record expression like this {{{ { ..., f1: flatten e1, f2 : flatten e2, ... , fn: flatten en,...}}} is equivalent to {{{ for( v1 in e1, v2 in e2, ..., vn in en) {..., f1: v1, f2: v2, ..., fn: vn,...} }}}. 

{{{
// literal record
{ x: "value", y: 12, "field with spaces" : 34.2}
// record with subexpressions for field values
basename="test";
{ filename: basename+".txt", size: count(somevariable)};
// record with subexpressions for field names
{ ("a"+"field"):  null, (basename) : "hi" }
// omit null fields (yields {required: null} as a result)
{ required: null, optional?: null}
// variable as field (yields { basename: "test"}
{basename} 
// path expressions
x={a: "value", b: "value"};
{ x.a } // copy field a from x
{x.*} // copy all fields from x
}}}

=== Array ===

== Arithmetic Expressions ==
TODO

== Boolean Expressions ==
TODO

== Path Expressions ==
TODO

== Blocks ==
TODO

== If-Then-Else ==
TODO

== Pipe and Function ==

Take from data model section for functions.
Pipe TODO.

== Partitioned Array Expressions ==

Link to JaqlCore.