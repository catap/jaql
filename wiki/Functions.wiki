#summary Extending Jaql's Functions

= Introduction =

Jaql has been designed to be extensible.  There are several ways to extend Jaql's capability:

  * Define new functions specified using Jaql
  * Define new functions specified using Java (we are working on other language bindings)
  * Customize or define new data accessors using JaqlIO

= Writing Aggregate Functions =

Jaql includes standard database aggregate functions, like 
{{{sum,count, min, max,}}} and {{{avg}}}.  Starting with Release
0.2, Jaql supports partial aggregation for these functions using
"combiners" inside Hadoop's map/reduce framework for greater
parallelism and reduced data shipping.  Syntactically, these functions
look like "holistic" aggregate functions -- an aggregate that requires
all the data before returning an answer.  However, they actually
expand into "algebraic" aggregates using the combine expression.
Median is the typical example of a holistic function:

{{{
  $median = fn($items) (
    $sorted = sort( $i in $items by $i ),

    $sorted[int(count($sorted)/2)]
  );

  $median( [ 1, 4, 5, 3, 2 ] ); // 3
}}}

If you need the exact median, we cannot improve upon this much.  But
consider variance instead.  It can be computed from the sum of the
numbers and the sum of squares.  The {{{combine}}} expression
is used to define "algebraic" aggregates -- an aggregate that can be
applied on portions of the data and combined to produce a final
result.  Such aggregates typically have an "initialization phase" that
creates a partial aggregate from a single item, a "combining phase"
where partial aggregates are combined into larger partial aggregates,
and a "final phase" that transforms the largest partial aggregate into
the desired result.

The {{{combine}}} expression handles the combining
phase. It takes any two partial aggregates from its input, aggregates
them using the combining expression, and conceptually puts the result
back into the input until the input is reduced to a single item.  The
following example defines variance completely in Jaql using
{{{combine}}}:

{{{
  $var = fn($items) (
    $init = 
       for( $i in $items )
        if( not isnull($i) )
         [{ n: 1, s1: $i, s2: $i*$i }],
    $combined =
       combine( $a, $b in $init )
           { n: $a.n  + $b.n,
            s1: $a.s1 + $b.s1,
            s2: $a.s2 + $b.s2 },
    $E_X  = $combined.s1 / $combined.n,
    $E_X2 = $combined.s2 / $combined.n,

    $E_X2 - $E_X * $E_X
  );

  $var( [ 1, 4, 5, 3, 2 ] ); // 2
}}}

Many functions are cumbersome to define in a query language.  
JavaFunctions are also useful for defining both holistic and algebraic aggregates.

= Extending Jaql =

In this section, we briefly describe some interesting functions that
we have added to Jaql.  The first example is mapReduce(), 
which takes a Jaql description of
the map and reduce functions as input, and uses it to run a map/reduce
job in Hadoop.

{{{
// Write to an HDFS file called 'sample'.
  hdfsWrite('sample.dat', [
    {x: 0, text: 'zero'},
    {x: 1, text: 'one'},
    {x: 0, text: 'two'},
    {x: 1, text: 'three'},
    {x: 0, text: 'four'},
    {x: 1, text: 'five'},
    {x: 0, text: 'six'},
    {x: 1, text: 'seven'},
    {x: 0, text: 'eight'}
  ]);
	
  // Run a map/reduce job that counts the number objects
  // for each 'x' value.
  mapReduce( 
    { input:  {type: 'hdfs', location: 'sample.dat'}, 
      output: {type: 'hdfs', location: 'results.dat'}, 
      map:    fn($i) [ [$i.x, 1] ], 
      reduce: fn($x, $v) [ {x: $x, num: count($v)} ]
    });
	
  // Read the results...
  hdfsRead('results.dat');
	
  // result...
  [
    {x: '0', num: 5},
    {x: '1', num: 4}
  ];
}}}

This example groups the input on 'x' and counts the 
number of objects in each group.
The map function must specify how to extract a key-value pair, 
and the reduce function must specify how to aggregate the
values for a given key.
Here, the key value is set to $i.x and count($v) is 
used to count the values $v associated with each key.
Note that both the map and reduce functions need to output an array
because each input is allowed to produce multiple outputs.

We have found mapReduce() to come in handy for many map/reduce jobs.
In general, the body of the map and reduce functions can
be Jaql expressions, so a lot of expressive power is available
to programmers who want to work with JSON data.
By working in Jaql, programmers are freed from all the little
details required to actually set up and run a map/reduce job.

The mapReduce() function touches on a interesting feature of Jaql,
namely that Jaql is a second-order language.
This allows function definitions to be assigned to variables
-- even stored in the database --
and later evaluated, as shown in the following example.

{{{
  // Define a function that returns the most recent book
  // written by a given author.
  $mostRecent = fn($author) (
        $authorsBooks =
           for( $b in hdfsRead('books') )
            if( $b.author == $author )
             [{ title: $b.title, year: $b.year }],
         $sorted = sort( $b in $authorsBooks by $b.year desc ),
        
      $sorted[0].title
    );
    
		// Invoke the function.
  $mostRecent('J. K. Rowling');

  // result...
  'Deathly Hallows';
}}}