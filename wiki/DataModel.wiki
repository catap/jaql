Jaql's types and schema language.

= Data Model =

Jaql's data model is based on !JavaScript Object Notation or [http://www.json.org/ JSON].
When using literal values in the language (e.g., 42 or "a string" as used in the expressions x = 42 and y == "a string"), the values are specified as JSON. In addition, Jaql has extended JSON with several commonly needed data types. Thus, Jaql accepts valid JSON data but it may not produce valid JSON when non-JSON types are used. 

Jaql also includes a powerful schema language to describe data. It includes ideas from [http://json-schema.org/ JSON Schema], [http://www.w3.org/XML/Schema XML schema], and [http://www.relaxng.org/ RELAX NG], but tailored to Jaql's syntax. Jaql schema is used as a constraint on data and to improve efficiency where applicable.

Jaql's [#Types types] are first described, followed by its [#Schema_Language schema language].


= Types =
  * [#Complex_Types Complex Types]
    * [#array array]
    * [#record record]
  * [#Atomic_Types Atomic Types]
    * [#null null]
    * [#boolean boolean]
    * [#string string]
    * [#Numeric_Types Numeric Types]
      * [#long long]
      * [#double double]
      * [#decfloat decfloat]
    * [#binary binary]
    * [#date date]
    * [#schematype schematype]
    * [#function function]
    * [#comparator comparator]
    

==Complex Types==
=== array ===
An array is a list of values. It corresponds to JSON's array type.

Examples:
{{{
  // empty array
  []

  // array with three longs
  [ 1, 2, 3 ]

  // array with mixed atomic types
  [ 1, "a", 3 ]

  // array with nested, complex data
  [ 1, ["a", "b"], [["a", "b"]], ["a", ["b", ["c"]]], {name: "value"}, 2 ]
}}}

=== record ===
A record is a mapping from names to values. It corresponds to JSON's object type.

Examples:
{{{
  // record with one field, whose name is "aName" and whose value is "val"
  { "aName": "val" }

  // jaql permits names to be specified with the double-quotes
  { aName: "val" }

  // a record with mixed atomic types
  { a: "val", b: 5 }

  // a record with a complex type for one of its fields
  { a: [1,2,3], b: "val" }
}}}

== Atomic Types ==
=== null ===
Just like SQL as well as JSON, jaql's data model includes {{{null}}}.

Examples:
{{{
  // the null value
  null

  // the null value used within a record
  { a: null, b: 1 }
}}}

=== boolean ===
The literal values for the boolean type are {{{true, false}}}. This is the same
as in JSON.

Examples:
{{{
  // the boolean value for TRUE
  true

  // the boolean value for FALSE
  false

  // an array with two boolean values included
  [ 1, true, 3, false, 4 ]
}}}

=== string ===
Strings are specified much the same way as in JSON. The only exception is that jaql's
parser permits single quotes, in addition to the double quotes that are specified by 
the JSON standard.

Examples:
{{{
  "some string"

  'some string'

  "some string with an \\n embedded newline"

  "some string with an embedded \\u1234 unicode char"
}}}
=== Numeric Types ===
The numeric types that are supported include {{{long}}}, {{{double}}} and {{{decfloat}}} (e.g., Decimal). The {{{decfloat}}} type corresponds to JSON's numeric type whereas {{{long}}} and {{{double}}} are explicitly supported for performance and convenience.

=== long ===
A 64-bit signed integer. If a number can be of type long, then it will be represented as a long by default.

Examples:
{{{
  1;

  -1;

  104;
}}}
=== double ===
A 64-bit base-2 floating point value. If a number can be of type double, and is not a long, then it will be represented as a double by default. A number can be coerced to be a double by using a 'd' suffix.

Examples:
{{{
  1.0;

  3.5;

  3d;

  100e-2;
}}}
=== decfloat ===
A 128-bit base-10 floating point value. A number can be specified to be a decimal only if suffixed by 'm'. The current implementation of decimal handling has lead us to use longs and doubles where possible.

Examples:
{{{
  1.0m;

  3.5m;

  3dm;

  100e-2m;
}}}
=== binary ===
Binary values are represented as hexadecimal strings and constructed with the {{{hex}}} constructor. Note that binary values are provided as a convenience and are not directly supported by JSON.

Examples:
{{{
  hex('F0A0DDEE');
}}}
=== date ===
Date values are represented using the following string format: 
{{{"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"}}}. If an alternative format is needed,
the format can be specified as the second argument to {{{date}}}.

Examples:
{{{
  date('2001-07-04T12:08:56.000Z');
}}}
== schematype ==
Schemata are represented in Jaql with the {{{schema}}} type. The basic
pattern to follow is {{{schema <schema expression>}}}. What follows are
several simple examples of schema values; the section on [#Schema_Language schema language] discusses {{{<schema expression>}}} options in more detail:

Examples:
{{{
  schema null;

  schema boolean;

  schema long|date;

  schema [ long, boolean * ];

  schema { a: long, b: null };

  schema schematype;
}}}
== function ==
Functions are part of Jaql's data types. They are specified using the following
pattern: {{{fn( <param>* ) <body>}}} where {{{<param>}}} is {{{ [schema] name[=val] }}}.
That is, a {{{param}}} can have an optional schema and an optional default
value associated. The {{{<body>}}} is defined by any Jaql expression. Since functions are simply values, they can be assigned to variables which can be invoked.

Examples:
{{{
  fn() 1+2; // creates a function value

  (fn() 1+2 )(); // invokes an anonymous function

  x = fn() 1+2; // creates a function and assigns it to the variable x

  x(); // invokes a function that returns 3

  y = fn(a,b) a + b;

  y(3,5);

  y = fn(schema long a, schema long b) a + b; // specify parameter schema

  y = fn(a=1, b=1) a + b; // specify default values

  y(); // invocation will use default values

  y(2); // bind 2 to a and use b's default value (yields 3)

  y(2,3); // override the default values

  y(b=2, a=3); // use the parameter name to explicitly bind to parameter value

  y = fn(schema long a=1, schema long b=1) a + b; // combine schemas and default values
}}}
== comparator ==
A comparator is similar to a function except that it is used specifically to construct a comparator. In particular, it is used by {{{sort}}} and {{{top}}}. The built-in function {{{topN}}} explicitly exposes comparators. For the most part, however, comparators are used for Jaql built-in and core operator implementations. 

A comparator is specified as follows: {{{cmp( <param> ) [ <body> asc | desc ]}}}. Essentially, a comparator specifies how a single value ({{{param}}}) is to be transformed ({{{<body>}}}) and compared against other transformed values. The {{{asc}}} and {{{desc}}}
keywords determine whether the comparator can be used to sort in ascending or descending order. 

Examples:
{{{
  cmp(x) [ x desc ]; // compares x values in descending order

  cmp(x) [ x.someField asc ]; // assumes x is a record and compares values associated with someField in ascending order
}}}

= Schema Language =