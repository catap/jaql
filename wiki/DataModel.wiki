Jaql's types and schema language.

= Data Model =

Jaql's data model is based on !JavaScript Object Notation or [http://www.json.org/ JSON].
When using literal values in the language (e.g., 42 or "a string" as used in the expressions x = 42 and y == "a string"), the values are specified as JSON. In addition, Jaql has extended JSON with several commonly needed data types. Thus, Jaql accepts valid JSON data but it may not produce valid JSON when non-JSON types are used. 

Jaql also includes a powerful schema language to describe data. It includes ideas from [http://json-schema.org/ JSON Schema], [http://www.w3.org/XML/Schema XML schema], and [http://www.relaxng.org/ RELAX NG], but tailored to Jaql's syntax. Jaql schema is used as a constraint on data and to improve efficiency where applicable.

Jaql's [#Types types] are first described, followed by its [#Schema_Language schema language].


= Types =
  * [#Complex_Types Complex Types]
    * [#array array]
    * [#record record]
  * [#Atomic_Types Atomic Types]
    * [#null null]
    * [#boolean boolean]
    * [#string string]
    * [#Numeric_Types Numeric Types]
      * [#long long]
      * [#double double]
      * [#decfloat decfloat]
    * [#binary binary]
    * [#date date]
    * [#schematype schematype]
    * [#function function]
    * [#comparator comparator]
    

==Complex Types==
=== array ===
An array is a list of values. It corresponds to JSON's array type.

Examples:
{{{
  // empty array
  []

  // array with three longs
  [ 1, 2, 3 ]

  // array with mixed atomic types
  [ 1, "a", 3 ]

  // array with nested, complex data
  [ 1, ["a", "b"], [["a", "b"]], ["a", ["b", ["c"]]], {name: "value"}, 2 ]
}}}

=== record ===
A record is a mapping from names to values. It corresponds to JSON's object type.

Examples:
{{{
  // record with one field, whose name is "aName" and whose value is "val"
  { "aName": "val" }

  // jaql permits names to be specified with the double-quotes
  { aName: "val" }

  // a record with mixed atomic types
  { a: "val", b: 5 }

  // a record with a complex type for one of its fields
  { a: [1,2,3], b: "val" }
}}}

== Atomic Types ==
=== null ===
Just like SQL as well as JSON, jaql's data model includes {{{null}}}.

Examples:
{{{
  // the null value
  null

  // the null value used within a record
  { a: null, b: 1 }
}}}

=== boolean ===
The literal values for the boolean type are {{{true, false}}}. This is the same
as in JSON.

Examples:
{{{
  // the boolean value for TRUE
  true

  // the boolean value for FALSE
  false

  // an array with two boolean values included
  [ 1, true, 3, false, 4 ]
}}}

=== string ===
Strings are specified much the same way as in JSON. The only exception is that jaql's
parser permits single quotes, in addition to the double quotes that are specified by 
the JSON standard.

Examples:
{{{
  "some string"

  'some string'

  "some string with an \\n embedded newline"

  "some string with an embedded \\u1234 unicode char"
}}}
=== Numeric Types ===
The numeric types that are supported include {{{long}}}, {{{double}}} and {{{decfloat}}} (e.g., Decimal). The {{{decfloat}}} type corresponds to JSON's numeric type whereas {{{long}}} and {{{double}}} are explicitly supported for performance and convenience.

=== long ===
A 64-bit signed integer. If a number can be of type long, then it will be represented as a long by default.

Examples:
{{{
  1;

  -1;

  104;
}}}
=== double ===
A 64-bit base-2 floating point value. If a number can be of type double, and is not a long, then it will be represented as a double by default. A number can be coerced to be a double by using a 'd' suffix.

Examples:
{{{
  1.0;

  3.5;

  3d;

  100e-2;
}}}
=== decfloat ===
A 128-bit base-10 floating point value. A number can be specified to be a decimal only if suffixed by 'm'. The current implementation of decimal handling has lead us to use longs and doubles where possible.

Examples:
{{{
  1.0m;

  3.5m;

  3dm;

  100e-2m;
}}}
=== binary ===
Binary values are represented as hexadecimal strings and constructed with the {{{hex}}} constructor. Note that binary values are provided as a convenience and are not directly supported by JSON.

Examples:
{{{
  hex('F0A0DDEE');
}}}
=== date ===
Date values are represented using the following string format: 
{{{"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"}}}. If an alternative format is needed,
the format can be specified as the second argument to {{{date}}}.

Examples:
{{{
  date('2001-07-04T12:08:56.000Z');
}}}
== schematype ==
== function ==
== comparator ==

= Schema Language =