/*
 * Copyright (C) IBM Corp. 2008.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
/**
 * JavaCC file
 */
 
options {
	JDK_VERSION = "1.5";
    STATIC=false;
    UNICODE_INPUT=true;
}

PARSER_BEGIN(JsonParser)
package com.ibm.jaql.json.parser;

import java.io.StringReader;
import java.io.IOException;
import java.util.ArrayList;

import com.ibm.jaql.json.constructor.JConstructor;
import com.ibm.jaql.json.type.Item;
import com.ibm.jaql.json.type.JString;
import com.ibm.jaql.json.type.JLong;
import com.ibm.jaql.json.type.JDecimal;
import com.ibm.jaql.json.type.JDouble;
import com.ibm.jaql.json.type.JBool;
import com.ibm.jaql.json.type.FixedJArray;
import com.ibm.jaql.json.type.MemoryJRecord;

import com.ibm.jaql.util.BaseUtil;


/** 
 *  This class is generated by JavaCC. Don't modify it directly.
 */
public class JsonParser 
{
  public JsonParser() 
  {
  	this(new StringReader(""));
  }
  
  public Item parse(String jsonString) throws ParseException 
  {
    ReInit(new StringReader(jsonString));
    try 
    {
      return TopVal();
    }
    catch (ParseException e) 
    {
      // rethrow to include the original jsonString:
      throw new ParseException("Cannot parse '" +jsonString+ "': " + e.getMessage());
    }
  }
}
PARSER_END(JsonParser)

SKIP:
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}

TOKEN:
{
	<COLON:       ":" >
|	<COMMA:       "," >
|	<#DIGIT:      ["0"-"9"] >
|	<#LETTER:     ["a"-"z","A"-"Z"] >
|	<MAP_BEGIN:   "{" >
|	<MAP_END:     "}" >
|	<ARRAY_BEGIN: "[" >
|	<ARRAY_END:   "]" >
|   <LPAREN:      "(" >
|   <RPAREN:      ")" >
|   <PLUS:        "+" >
|   <LONG:        ("-")? (<DIGIT>)+ >
|   <REAL:        ("-")? (<DIGIT>)+ "." (<DIGIT>)+ >
|   <DECIMAL:     ("-")? (<DIGIT>)+ "." (<DIGIT>)+ "m" >
|   <DOUBLE:      ("-")? (<DIGIT>)+ ("." (<DIGIT>)+)? "d" >
|   <TRUE:        ["t","T"]["r","R"]["u","U"]["e","E"] >
|   <FALSE:       ["f","F"]["a","A"]["l","L"]["s","S"]["e","E"] >
|   <NULL:        ["n","N"]["u","U"]["l","L"]["l","L"] >
|   <ID:    ("@"|"_"|<LETTER>) ("@"|"_"|"#"|<LETTER>|<DIGIT>)* >
}

MORE:
{
	< "'"  > { image.setLength(0); } : IN_STRING1
|	< "\"" > { image.setLength(0); } : IN_STRING2
}

<IN_STRING1> TOKEN: { <STRING1: "'"  > { image.setLength(image.length()-1); matchedToken.image = image.toString(); } : DEFAULT }
<IN_STRING2> TOKEN: { <STRING2: "\"" > { image.setLength(image.length()-1); matchedToken.image = image.toString(); } : DEFAULT }

<IN_STRING1, IN_STRING2> MORE:
{
  <"\\\r\n">           { image.setLength(image.length()-3); }
| <("\\" ("\n"|"\r"))> { image.setLength(image.length()-2); }
| <"\r\n"> {
      int l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\n');
  }
| <"\n">
| <"\r"> { image.setCharAt(image.length()-1, '\n'); }
| <"\\\'"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\'');
  }
| <"\\\"" > {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\"');
  }
| <"\\\\"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\\');
  }
| <"\\/"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '/');
  }
| <"\\b"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\b');
  }
| <"\\f"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\f');
  }
| <"\\n"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\n');
  }
| <"\\r"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\r');
  }
| <"\\t"> {
      l = image.length();
      image.setLength(l-1);
      image.setCharAt(l-2, '\t');
  }
| <"\\" ("x"|"X") ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]> {
      l = image.length();
      byte b = BaseUtil.parseHexByte(image.charAt(l-2), image.charAt(l-1));
      image.setLength(l-3);
      image.setCharAt(l-4, (char)(b & 0xff));
  }
| <"\\" ("u"|"U") ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]> {
      l = image.length();
      char c = BaseUtil.parseUnicode(image.charAt(l-4), image.charAt(l-3), image.charAt(l-2), image.charAt(l-1));
      image.setLength(l-5);
      image.setCharAt(l-6, c);
  }
| <~["\\", "\n","\r"]>
}

SKIP :
{
  "/*" : WithinComment
| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

<WithinComment> SKIP :
{
  "*/" : DEFAULT
}

<WithinComment> MORE :
{
  <~[]>
}


//  syntax BNF:
//  TopVal    ::= JsonVal
//  JsonVal    ::= MapVal | ArrayVal | AtomVal
//  MapVal    ::= { MapFields }
//  MapFields ::= Field_name : TopVal (, MapFields)*
//  ArrayVal  ::= [ ArrayItems ]
//  ArrayItems::= TopVal (, ArrayItems)*
//  AtomVal   ::= <strvalue> | <long> | <decimal>
//
// This parser can be used in the following ways:
//
// 1) To parse a single JSON value, which is placed all in memory:
//
//        Item item = parser.JsonVal();
//        parser.Eof(); // optional EOF check
//
// 2) To parse a single JSON value and do the EOF check in one call (same as above):
//
//       Item item = parser.TopVal();
// 
// 3) To parse a top-level array of JSON values, one at a time
//
//        for( Item item = parser.ArrayFirst() ; item != null ; item = parser.ArrayNext() )  
//        {
//           // process item
//        }
//        parser.Eof(); // optional EOF check
//
//    Note: The parser keeps only one item in memory at a time, but a new item is returned
//    each time so it is safe to keep a handle on prior items.
//
// If you want to ensure that the entire buffer was processed, parser.Eof() can be called
// after JsonVal() or when ArrayFirst()/ArrayNext() returns null.  


Item JsonVal() :
{
	Item item;
}
{
	( item=ArrayVal()
	| item=MapVal() 
	| item=AtomVal()
	)
	{ return item; }
}

void Eof() :
{
}
{
	<EOF>
}


Item TopVal() :
{
	Item item;
}
{
	item=JsonVal() Eof()
	{ return item; }
}


Item ArrayFirst() :
{
	Item item = null;
}
{
	<ARRAY_BEGIN> (item=JsonVal())?		
	{ return item; }
}

Item ArrayNext() :
{
	Item item;
}
{
	( <COMMA> item=JsonVal()	{ return item; }
	| <ARRAY_END>				{ return null; }
	)
}

Item ArrayVal() :
{
	Item[] items;
}
{
	<ARRAY_BEGIN> items=ItemList() <ARRAY_END>
	{ return new Item(new FixedJArray(items)); }
}

Item MapVal() :
{
	MemoryJRecord jRecord = new MemoryJRecord();
}
{
	<MAP_BEGIN> 
	  ( MapField(jRecord) 
	    ( <COMMA> MapField(jRecord) )*
	  )?
	<MAP_END>
	{ return new Item(jRecord);	}
}

void MapField(MemoryJRecord jRecord) :
{
	String name;
	Item item;
}
{
	name=Name() <COLON> item=JsonVal()
	{ jRecord.add(name, item); }
}


String Name() :
{
	Token tok;
}
{
	tok=<ID>      { return tok.image; }
|	tok=<STRING1> { return tok.image; }
|	tok=<STRING2> { return tok.image; }
}

Item AtomVal() :
{
	Item item;
	Token atom;
	String s;
}
{
	( s=String()       { item = new Item(new JString(s)); }
	| atom=<LONG>      { item = new Item(new JLong(atom.image)); }
	| atom=<REAL>      { item = new Item(new JDecimal(atom.image)); } // TODO: flag for double vs decimal default
	| atom=<DECIMAL>   { item = new Item(new JDecimal(atom.image)); }
	| atom=<DOUBLE>    { item = new Item(new JDouble(atom.image)); }
	| atom=<TRUE>      { item = JBool.trueItem; }
	| atom=<FALSE>     { item = JBool.falseItem; }
	| atom=<NULL>      { item = Item.nil; }
	| item=Construct()
	)
	{ return item; }	
}

Item Construct() :
{
	Token fn;
	Item[] items;
}
{
	fn=<ID> <LPAREN> items=ItemList() <RPAREN>
	{ return JConstructor.eval(fn.image, items); }
}


Item[] ItemList() :
{
	ArrayList<Item> items = new ArrayList<Item>();
	Item item;
}
{
	( item=JsonVal()           { items.add(item); }
	  ( <COMMA> item=JsonVal() { items.add(item); }
	  )*
	)?
	{ return items.toArray(new Item[items.size()]); }
}


String String() :
{
	String str;
	String str2;
}
{
	str=String1() ( (<PLUS>)? str2=String1() { str += str2; } )*
	{ return str; }
}

String String1() :
{
	Token tok;
}
{
	tok=<STRING1> { return tok.image; }
|	tok=<STRING2> { return tok.image; }
}

